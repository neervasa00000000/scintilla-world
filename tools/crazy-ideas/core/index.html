<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CORE - Holographic Thought Engine</title>
  <link rel="icon" type="image/png" href="../../../assets/logo/scintilla.png">
  <link rel="apple-touch-icon" href="../../../assets/logo/scintilla.png">
  <link rel="shortcut icon" href="../../../assets/logo/scintilla.png">
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- React and ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  
  <!-- Babel Standalone for JSX transformation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <style>
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes slideUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .animate-fadeIn { animation: fadeIn 1s ease-out; }
    .animate-slideUp { animation: slideUp 0.8s ease-out forwards; }
    body { background-color: #020202; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;
    
    // --- ICONS ---
    const Sparkles = ({ size = 24, className = "" }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}><path d="M12 2v20M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>
    );
    const Scan = ({ size = 24, className = "" }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}><path d="M3 7V5a2 2 0 0 1 2-2h2M17 3h2a2 2 0 0 1 2 2v2m0 6v2a2 2 0 0 1-2 2h-2M7 21H5a2 2 0 0 1-2-2v-2"></path></svg>
    );
    const Rotate3d = ({ size = 24, className = "" }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}><path d="M16.466 7.5C15.643 4.237 13.952 2 12 2 9.239 2 7 6.477 7 12s2.239 10 5 10c.342 0 .677-.069 1-.2"></path><path d="M7.534 16.5C8.357 19.763 10.048 22 12 22c2.761 0 5-4.477 5-10s-2.239-10-5-10c-.342 0-.677.069-1 .2"></path><path d="M12 2v20"></path></svg>
    );
    const Zap = ({ size = 24, className = "" }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>
    );
    const Volume2 = ({ size = 24, className = "" }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
    );
    const VolumeX = ({ size = 24, className = "" }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
    );
    const Music = ({ size = 24, className = "" }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>
    );

    // --- AUDIO UTILITIES ---
    const SCALES = {
      'ETHREAL': [0, 2, 4, 6, 7, 9, 11], // Lydian (Dreamy)
      'MYSTERY': [0, 2, 3, 5, 7, 9, 10], // Dorian (Sci-fi)
      'HOPE':    [0, 2, 4, 5, 7, 9, 11], // Major (Happy)
      'DEEP':    [0, 2, 3, 5, 7, 8, 10], // Minor (Sad/Serious)
      'ZEN':     [0, 2, 4, 7, 9],        // Pentatonic (Neutral)
    };

    const midiToFreq = (note) => 440 * Math.pow(2, (note - 69) / 12);

    // --- MATH UTILITIES (3D Projection Engine) ---
    const generateCoreParams = (str) => {
      let h = 0xdeadbeef;
      for (let i = 0; i < str.length; i++) {
        h = Math.imul(h ^ str.charCodeAt(i), 2654435761);
      }
      const s = ((h >>> 0) / 4294967296);
      
      const scaleKeys = Object.keys(SCALES);
      const scaleName = scaleKeys[Math.floor(s * scaleKeys.length)];
      // Map hash to a root note between F3 (53) and C5 (72)
      const rootMidi = 53 + Math.floor(s * 20);

      return {
        ringCount: Math.floor(s * 4) + 3, // 3 to 7 rings
        coreDensity: Math.floor(s * 500) + 300,
        chaos: s > 0.5,
        speed: 0.005 + (s * 0.02),
        hue: Math.floor(s * 360),
        hueRange: 60,
        tilt: (s - 0.5) * 2, // Random tilt
        // Audio Params
        scaleName: scaleName,
        scaleIntervals: SCALES[scaleName],
        rootMidi: rootMidi,
        bpm: 60 + (s * 60)
      };
    };

    const HologramCanvas = ({ text }) => {
      const canvasRef = useRef(null);
      const containerRef = useRef(null);
      
      const [rotation, setRotation] = useState({ x: 0, y: 0 });
      const isDragging = useRef(false);
      const lastMouse = useRef({ x: 0, y: 0 });
      const params = useMemo(() => generateCoreParams(text), [text]);
      
      // --- 3D PARTICLE SYSTEM SETUP ---
      const particles = useMemo(() => {
        const pts = [];
        // 1. Core (Sphere)
        for (let i = 0; i < params.coreDensity; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);
          const r = 40 + Math.random() * 20; 
          pts.push({
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi),
            type: 'core',
            size: Math.random() * 1.5,
            phase: Math.random() * Math.PI
          });
        }
        // 2. Rings
        for (let r = 0; r < params.ringCount; r++) {
          const radius = 80 + (r * 30);
          const ringTiltX = (Math.random() - 0.5) * 2;
          const particleCount = 100 + (r * 50);
          for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2;
            let px = radius * Math.cos(angle);
            let py = 0;
            let pz = radius * Math.sin(angle);
            
            const tx = px;
            const ty = py * Math.cos(ringTiltX) - pz * Math.sin(ringTiltX);
            const tz = py * Math.sin(ringTiltX) + pz * Math.cos(ringTiltX);
            
            pts.push({
              x: tx, y: ty, z: tz,
              type: 'ring',
              size: Math.random() * 1.2,
              speed: (r % 2 === 0 ? 1 : -1) * (0.01 + Math.random() * 0.005),
              angle: angle,
              radius: radius,
              tiltX: ringTiltX
            });
          }
        }
        return pts;
      }, [params]);

      // --- INTERACTION ---
      const handleMouseDown = (e) => {
        isDragging.current = true;
        lastMouse.current = { x: e.clientX, y: e.clientY };
      };
      
      const handleMouseMove = (e) => {
        if (!isDragging.current) return;
        const deltaX = e.clientX - lastMouse.current.x;
        const deltaY = e.clientY - lastMouse.current.y;
        setRotation(prev => ({ x: prev.x + deltaY * 0.01, y: prev.y + deltaX * 0.01 }));
        lastMouse.current = { x: e.clientX, y: e.clientY };
      };
      
      const handleMouseUp = () => { isDragging.current = false; };

      // --- RENDER LOOP ---
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        let animationId = null;
        
        const initCanvas = () => {
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          const rect = canvas.getBoundingClientRect();
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          ctx.scale(dpr, dpr);
          return { width: rect.width, height: rect.height };
        };
        
        const { width, height } = initCanvas();
        const cx = width / 2;
        const cy = height / 2;
        const fov = 400; 
        let time = 0;
        
        const render = () => {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
          ctx.fillRect(0, 0, width, height);
          ctx.globalCompositeOperation = 'lighter';
          
          const autoRotY = time * 0.2;
          const rotX = rotation.x;
          const rotY = rotation.y + autoRotY;
          const pulse = 1 + Math.sin(time * 3) * 0.05;
          
          particles.forEach(p => {
            let x = p.x; let y = p.y; let z = p.z;
            
            if (p.type === 'ring') {
              p.angle += p.speed;
              const px = p.radius * Math.cos(p.angle);
              const pz = p.radius * Math.sin(p.angle);
              x = px; y = 0; z = pz;
              const ty = y * Math.cos(p.tiltX) - z * Math.sin(p.tiltX);
              const tz = y * Math.sin(p.tiltX) + z * Math.cos(p.tiltX);
              y = ty; z = tz;
            } else {
              x *= pulse; y *= pulse; z *= pulse;
            }
            
            // Rotation
            let tx = x * Math.cos(rotY) - z * Math.sin(rotY);
            let tz = x * Math.sin(rotY) + z * Math.cos(rotY);
            x = tx; z = tz;
            let ty = y * Math.cos(rotX) - z * Math.sin(rotX);
            tz = y * Math.sin(rotX) + z * Math.cos(rotX);
            y = ty; z = tz;
            
            const scale = fov / (fov + z);
            const x2d = cx + x * scale;
            const y2d = cy + y * scale;
            
            if (z > -fov) {
              const alpha = p.type === 'core' ? 0.8 : 0.6;
              let hue = params.hue;
              if (p.type === 'ring') hue = (params.hue + 40) % 360;
              
              ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;
              const size = p.size * scale;
              ctx.beginPath();
              ctx.arc(x2d, y2d, size, 0, Math.PI * 2);
              ctx.fill();
            }
          });
          time += 0.01;
          animationId = requestAnimationFrame(render);
        };
        render();
        return () => { if (animationId) cancelAnimationFrame(animationId); };
      }, [particles, rotation, params]);

      return (
        <div ref={containerRef} className="relative w-full aspect-square bg-black rounded-full overflow-hidden shadow-[0_0_50px_rgba(255,255,255,0.1)] border border-white/10 cursor-move group"
          onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
          onTouchStart={(e) => handleMouseDown(e.touches[0])} onTouchMove={(e) => handleMouseMove(e.touches[0])} onTouchEnd={handleMouseUp}
        >
          <canvas ref={canvasRef} className="w-full h-full block" />
          <div className="absolute inset-0 bg-[linear-gradient(rgba(0,0,0,0)_50%,rgba(0,0,0,0.2)_50%),linear-gradient(90deg,rgba(255,0,0,0.06),rgba(0,255,0,0.02),rgba(0,0,255,0.06))] z-10 pointer-events-none bg-[length:100%_4px,6px_100%] opacity-50" />
          <div className="absolute bottom-6 left-0 right-0 text-center pointer-events-none opacity-0 group-hover:opacity-100 transition-opacity">
            <div className="inline-flex items-center gap-2 bg-black/60 backdrop-blur-md px-3 py-1 rounded-full border border-white/10 text-xs text-white/50">
              <Rotate3d size={12} /><span>DRAG TO ROTATE VIEW</span>
            </div>
          </div>
        </div>
      );
    };

    // --- MAIN APP ---
    function CoreApp() {
      const [input, setInput] = useState('');
      const [activeText, setActiveText] = useState('SYSTEM READY');
      const [generated, setGenerated] = useState(false);
      const [audioEnabled, setAudioEnabled] = useState(false);

      // Audio Refs
      const ctxRef = useRef(null);
      const nodesRef = useRef([]);
      const sequencerRef = useRef(null);
      const params = useMemo(() => generateCoreParams(activeText), [activeText]);

      // --- AUDIO ENGINE ---
      const startAudio = (p) => {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) return;
        if (!ctxRef.current) ctxRef.current = new AudioContext();
        const ctx = ctxRef.current;
        if (ctx.state === 'suspended') ctx.resume();

        stopAudio();
        const now = ctx.currentTime;

        // Master Volume
        const master = ctx.createGain();
        master.gain.setValueAtTime(0, now);
        master.gain.linearRampToValueAtTime(0.4, now + 2); 
        master.connect(ctx.destination);
        nodesRef.current.push(master);

        // 1. SOFT SHIMMER (Background)
        [0, 7, 12].forEach((interval, i) => {
           const osc = ctx.createOscillator();
           osc.type = 'sine'; 
           osc.frequency.value = midiToFreq(p.rootMidi + interval); 
           const g = ctx.createGain();
           g.gain.value = 0.03; 
           const filter = ctx.createBiquadFilter();
           filter.type = 'lowpass';
           filter.frequency.setValueAtTime(400, now);
           filter.frequency.linearRampToValueAtTime(800, now + 10); 
           osc.connect(filter).connect(g).connect(master);
           osc.start(now);
           nodesRef.current.push(osc, g, filter);
        });

        // 2. GENERATIVE MELODY
        const playNote = () => {
           const noteIndex = Math.floor(Math.random() * p.scaleIntervals.length);
           const midiNote = p.rootMidi + p.scaleIntervals[noteIndex] + (Math.random() > 0.7 ? 12 : 0);
           const freq = midiToFreq(midiNote);
           const osc = ctx.createOscillator();
           osc.type = 'sine';
           osc.frequency.setValueAtTime(freq, ctx.currentTime);
           const env = ctx.createGain();
           env.gain.setValueAtTime(0, ctx.currentTime);
           env.gain.linearRampToValueAtTime(0.3, ctx.currentTime + 0.1); 
           env.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 3.0); 

           if (ctx.createStereoPanner) {
              const pan = ctx.createStereoPanner();
              pan.pan.value = (Math.random() * 2) - 1; 
              osc.connect(env).connect(pan).connect(master);
           } else {
              osc.connect(env).connect(master);
           }
           osc.start(ctx.currentTime);
           osc.stop(ctx.currentTime + 3.5);
           
           const nextTime = (60 / p.bpm) * (Math.random() > 0.5 ? 1000 : 500); 
           sequencerRef.current = setTimeout(playNote, nextTime);
        };
        playNote();
      };

      const stopAudio = () => {
        if (sequencerRef.current) clearTimeout(sequencerRef.current);
        nodesRef.current.forEach(n => {
           try { if(n.stop) n.stop(); n.disconnect(); } catch(e){} 
        });
        nodesRef.current = [];
      };

      const toggleAudio = () => {
        if (audioEnabled) {
          if (ctxRef.current) ctxRef.current.suspend();
          stopAudio();
          setAudioEnabled(false);
        } else {
          startAudio(params);
          setAudioEnabled(true);
        }
      };
      
      useEffect(() => {
        return () => stopAudio();
      }, []);

      const handleGenerate = (e) => {
        e.preventDefault();
        if (input.trim()) {
          setActiveText(input);
          setGenerated(true);
          if (audioEnabled) {
            const newParams = generateCoreParams(input);
            startAudio(newParams);
          }
        }
      };

      const handleRandom = () => {
        const concepts = ["Singularity", "Hope", "Entropy", "Stardust", "Cybernetics", "Void", "Genesis", "Aeon"];
        const text = concepts[Math.floor(Math.random() * concepts.length)];
        setInput(text);
        setActiveText(text);
        setGenerated(true);
        if (audioEnabled) {
          const newParams = generateCoreParams(text);
          startAudio(newParams);
        }
      };

      return (
        <div className="min-h-screen bg-[#020202] text-white font-sans flex flex-col items-center justify-center p-4 relative overflow-hidden">
          <div className="absolute inset-0 z-0">
            <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[100vw] h-[100vw] bg-blue-900/5 rounded-full blur-[120px]" />
          </div>
          <div className="relative z-10 w-full max-w-md flex flex-col items-center">
            
            {/* Header */}
            <div className="text-center mb-8 animate-fadeIn">
              <h1 className="text-6xl font-black tracking-tighter text-transparent bg-clip-text bg-gradient-to-b from-white to-slate-600 mb-2">
                CORE
              </h1>
              <p className="text-slate-500 text-[10px] tracking-[0.4em] uppercase">
                Holographic Thought Engine
              </p>
            </div>
            
            {/* 3D Viewport */}
            <div className="w-full mb-8 relative">
               <HologramCanvas text={activeText} />
               <div className="absolute top-0 left-0 w-4 h-4 border-l border-t border-white/20 pointer-events-none" />
               <div className="absolute top-0 right-0 w-4 h-4 border-r border-t border-white/20 pointer-events-none" />
               <div className="absolute bottom-0 left-0 w-4 h-4 border-l border-b border-white/20 pointer-events-none" />
               <div className="absolute bottom-0 right-0 w-4 h-4 border-r border-b border-white/20 pointer-events-none" />
            </div>
            
            {/* Controls - AUDIO BUTTON IS NOW HERE */}
            <div className="w-full space-y-4 animate-slideUp">
              <form onSubmit={handleGenerate} className="relative group">
                <div className="absolute inset-0 bg-gradient-to-r from-blue-500/20 to-purple-500/20 rounded-xl blur-lg group-hover:blur-xl transition-all opacity-0 group-hover:opacity-100" />
                <input 
                  type="text" 
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  placeholder="Initialize Core Parameter..."
                  className="relative w-full bg-black/40 backdrop-blur-xl border border-white/10 text-center text-white p-5 rounded-xl focus:outline-none focus:border-white/30 transition-all font-medium text-lg placeholder-slate-600"
                />
              </form>
              
              <div className="grid grid-cols-3 gap-2">
                 <button 
                    onClick={handleGenerate}
                    disabled={!input}
                    className={`flex items-center justify-center gap-2 px-4 py-3 rounded-xl font-bold text-[10px] uppercase tracking-widest transition-all border border-transparent
                      ${input ? 'bg-white text-black hover:scale-105' : 'bg-white/5 text-slate-500 cursor-not-allowed'}
                    `}
                 >
                    <Scan size={14} /> Materialize
                 </button>
                 
                 <button onClick={handleRandom} className="flex items-center justify-center gap-2 p-3 rounded-xl bg-white/5 hover:bg-white/10 text-white border border-white/5 transition-all text-[10px] font-bold uppercase tracking-widest">
                   <Zap size={14} /> Random
                 </button>

                 <button 
                   onClick={toggleAudio}
                   className={`flex items-center justify-center gap-2 p-3 rounded-xl border transition-all text-[10px] font-bold uppercase tracking-widest
                     ${audioEnabled ? 'bg-green-900/30 border-green-500/50 text-green-400' : 'bg-white/5 border-white/5 text-slate-400 hover:text-white'}
                   `}
                 >
                   {audioEnabled ? <Music size={14} /> : <VolumeX size={14} />}
                   {audioEnabled ? 'ON' : 'MUTE'}
                 </button>
              </div>
            </div>
            
            {/* Stats */}
            {generated && (
              <div className="mt-8 grid grid-cols-3 gap-8 text-center w-full px-4 opacity-50">
                 <div>
                   <p className="text-[9px] text-slate-500 uppercase tracking-widest mb-1">Mass</p>
                   <p className="text-xs font-mono">{Math.floor(activeText.length * 42.5)} MB</p>
                 </div>
                 <div>
                   <p className="text-[9px] text-slate-500 uppercase tracking-widest mb-1">Spin</p>
                   <p className="text-xs font-mono">{activeText.length % 2 === 0 ? 'CLOCKWISE' : 'COUNTER'}</p>
                 </div>
                 <div>
                   <p className="text-[9px] text-slate-500 uppercase tracking-widest mb-1">Scale</p>
                   <p className="text-xs font-mono">{params.scaleName}</p>
                 </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.render(<CoreApp />, document.getElementById('root'));
  </script>
</body>
</html>