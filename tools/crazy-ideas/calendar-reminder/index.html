<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quick Calendar Reminder | NutriThrive Labs</title>
  <link rel="icon" type="image/png" href="https://i.imgur.com/bZubhoR.png">
  <link rel="apple-touch-icon" href="https://i.imgur.com/bZubhoR.png">
  <link rel="shortcut icon" href="https://i.imgur.com/bZubhoR.png">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --primary: #727D73;
      --primary-dark: #5a645a;
      --primary-light: #8a958a;
      --accent: #AAB99A;
      --accent-light: #c4d0b4;
      --bg-primary: #F0F0D7;
      --bg-secondary: #D0DDD0;
      --bg-tertiary: #ffffff;
      --text-primary: #2d3430;
      --text-secondary: #727D73;
      --text-muted: #AAB99A;
      --border: #D0DDD0;
      --border-dark: #AAB99A;
      --success: #727D73;
      --error: #c85a5a;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      min-height: 100vh;
      padding: 0;
      color: var(--text-primary);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      display: none;
    }

    body::after {
      display: none;
    }

    .container {
      max-width: 1100px;
      width: 100%;
      margin: 0 auto;
      padding: 100px 40px;
      position: relative;
      z-index: 1;
    }

    .header-section {
      text-align: center;
      margin-bottom: 80px;
      position: relative;
      animation: fadeInDown 0.8s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .header-section::after {
      display: none;
    }

    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }


    .main-content {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 40px;
      margin-bottom: 60px;
      align-items: start;
    }

    @media (max-width: 768px) {
      .main-content {
        grid-template-columns: 1fr;
        gap: 24px;
      }
    }

    h1 {
      color: var(--primary);
      font-size: 4.5rem;
      margin-bottom: 24px;
      font-weight: 800;
      letter-spacing: -0.06em;
      line-height: 1.05;
      position: relative;
      display: inline-block;
    }

    h1::before {
      content: 'üóìÔ∏è';
      display: inline-block;
      margin-right: 20px;
      font-size: 4rem;
      vertical-align: middle;
      position: relative;
      z-index: 1;
    }


    .subtitle {
      color: var(--text-secondary);
      font-size: 1.25rem;
      margin-bottom: 0;
      line-height: 1.8;
      font-weight: 400;
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
      padding: 0 20px;
      opacity: 0.9;
    }

    .subtitle em {
      color: var(--primary);
      font-style: normal;
      font-weight: 600;
    }

    .input-card {
      background: var(--bg-tertiary);
      border-radius: 32px;
      padding: 56px;
      border: 2px solid var(--border);
      position: relative;
      overflow: hidden;
    }

    .input-card:hover {
      border-color: var(--primary);
    }

    .input-card::before {
      display: none;
    }

    .info-card {
      background: var(--bg-secondary);
      border-radius: 32px;
      padding: 56px;
      border: 2px solid var(--border-dark);
      position: relative;
    }

    .info-card:hover {
      border-color: var(--primary);
    }

    .input-label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.875rem;
      font-weight: 700;
      color: var(--primary);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-bottom: 16px;
      text-align: left;
    }

    .input-label::before {
      content: '‚úçÔ∏è';
      font-size: 1.2rem;
    }

    textarea {
      width: 100%;
      min-height: 220px;
      padding: 32px;
      font-size: 1.1875rem;
      border-radius: 24px;
      border: 2px solid var(--border-dark);
      margin-bottom: 32px;
      outline: none;
      transition: border-color 0.3s ease;
      font-family: inherit;
      resize: vertical;
      background: var(--bg-secondary);
      color: var(--text-primary);
      line-height: 2;
      position: relative;
    }

    textarea:focus {
      border-color: var(--primary);
      background: var(--bg-tertiary);
      border-width: 3px;
    }

    textarea::placeholder {
      color: var(--text-muted);
      opacity: 0.6;
    }

    .button-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    button {
      flex: 1;
      min-width: 200px;
      padding: 22px 48px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 18px;
      font-size: 0.9375rem;
      font-weight: 700;
      cursor: pointer;
      transition: background-color 0.3s ease;
      letter-spacing: 0.06em;
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
    }

    button:hover {
      background: var(--primary-dark);
    }

    button:active {
      background: var(--primary-dark);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      background: var(--border);
    }

    .result {
      margin: 24px 0;
      animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .result-section {
      margin-top: 32px;
    }

    .event-summary {
      background: var(--bg-tertiary);
      border-left: 4px solid var(--primary);
      padding: 36px;
      border-radius: 24px;
      text-align: left;
      font-size: 1.0625rem;
      margin-bottom: 28px;
      color: var(--text-primary);
      border: 2px solid var(--border);
      border-left-width: 4px;
      position: relative;
      overflow: hidden;
    }

    .event-summary::after {
      display: none;
    }

    .event-summary b {
      color: var(--primary);
      font-weight: 700;
      font-size: 0.8125rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      display: block;
      margin-bottom: 8px;
      margin-top: 12px;
    }

    .event-summary b:first-child {
      margin-top: 0;
    }

    .event-summary br {
      margin-bottom: 8px;
      display: block;
      content: "";
    }

    .ics-link {
      display: inline-flex;
      align-items: center;
      gap: 12px;
      margin: 28px 0;
      padding: 18px 44px;
      background: var(--accent);
      color: var(--primary);
      border-radius: 16px;
      font-weight: 700;
      text-decoration: none;
      transition: background-color 0.3s ease, border-color 0.3s ease;
      font-size: 0.875rem;
      letter-spacing: 0.05em;
      border: 2px solid var(--accent);
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
    }

    .ics-link::before {
      content: 'üì•';
      font-size: 1.3rem;
    }

    .ics-link:hover {
      background: var(--accent-light);
      border-color: var(--primary);
    }

    .info-section {
      margin-top: 48px;
    }

    .tip {
      color: var(--text-secondary);
      background: var(--bg-tertiary);
      font-size: 0.9375rem;
      padding: 28px 32px;
      border-radius: 20px;
      border: 2px solid var(--border-dark);
      text-align: left;
      line-height: 1.9;
      position: relative;
      padding-left: 64px;
      margin-bottom: 32px;
      transition: border-color 0.3s ease;
    }

    .tip:hover {
      border-color: var(--primary);
    }

    .tip::before {
      content: 'üí°';
      position: absolute;
      left: 24px;
      top: 28px;
      font-size: 1.8rem;
    }

    .tip strong {
      color: var(--primary);
      font-weight: 700;
    }

    .error {
      color: var(--error);
      margin: 24px 0;
      font-weight: 600;
      padding: 24px 28px;
      border-radius: 16px;
      background: var(--bg-tertiary);
      border: 2px solid var(--error);
      border-left: 4px solid var(--error);
      text-align: left;
      line-height: 1.8;
      font-size: 0.9375rem;
      position: relative;
      padding-left: 56px;
    }

    .error::before {
      content: '‚ö†Ô∏è';
      position: absolute;
      left: 20px;
      top: 24px;
      font-size: 1.5rem;
    }

    .examples {
      background: var(--bg-tertiary);
      padding: 32px;
      border-radius: 20px;
      text-align: left;
      border: 2px solid var(--border);
      margin-top: 32px;
    }

    .examples h3 {
      color: var(--primary);
      font-size: 0.875rem;
      margin-bottom: 24px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      display: flex;
      align-items: center;
      gap: 12px;
      padding-bottom: 16px;
      border-bottom: 2px solid var(--border-dark);
    }

    .examples h3::before {
      content: 'üìù';
      font-size: 1.4rem;
    }

    .examples ul {
      list-style: none;
      padding: 0;
      display: grid;
      gap: 12px;
    }

    .examples li {
      color: var(--text-secondary);
      font-size: 0.9375rem;
      padding: 16px 20px;
      padding-left: 56px;
      position: relative;
      line-height: 1.8;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
      background: var(--bg-secondary);
      border-radius: 12px;
      border: 2px solid var(--border);
      cursor: pointer;
    }

    .examples li:hover {
      color: var(--primary);
      background: var(--bg-primary);
      border-color: var(--accent);
    }

    .examples li:before {
      content: "‚ú®";
      position: absolute;
      left: 20px;
      color: var(--accent);
      font-size: 1.1em;
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 0.8s linear infinite;
      margin-right: 8px;
      vertical-align: middle;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @media (max-width: 768px) {
      .container {
        padding: 32px 20px;
      }

      h1 {
        font-size: 2.5rem;
      }

      .subtitle {
        font-size: 1rem;
      }

      .input-card,
      .info-card {
        padding: 28px 24px;
      }

      textarea {
        min-height: 140px;
        padding: 20px;
      }

      button {
        width: 100%;
        min-width: auto;
      }

      .ics-link {
        width: 100%;
        justify-content: center;
      }

      .event-summary {
        padding: 24px;
      }

      .tip,
      .error {
        padding-left: 48px;
      }
    }

    @media (max-width: 480px) {
      .container {
        padding: 24px 16px;
      }

      h1 {
        font-size: 2rem;
      }

      .header-badge {
        font-size: 0.75rem;
        padding: 6px 16px;
      }

      .input-card,
      .info-card {
        padding: 24px 20px;
      }
    }
  </style>
  <script>
    // Enhanced date parser - handles many human-friendly formats
    const SimpleDateParser = {
      parse: function(text, refDate) {
        refDate = refDate || new Date();
        const now = new Date(refDate);
        const textLower = text.toLowerCase().trim();
        
        // Month names and abbreviations
        const months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];
        const monthAbbr = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
        
        // Helper to find month index
        const findMonth = function(monthStr) {
          if (!monthStr) return -1;
          const m = monthStr.toLowerCase();
          let idx = months.findIndex(month => month.startsWith(m));
          if (idx === -1) idx = monthAbbr.findIndex(abbr => abbr === m);
          return idx;
        };
        
        // Helper to parse year (handles 2-digit years)
        const parseYear = function(yearStr) {
          if (!yearStr) return now.getFullYear();
          const y = parseInt(yearStr);
          if (y < 100) {
            // 2-digit year: assume 20xx if >= current year - 2000, else 21xx
            const currentYear = now.getFullYear();
            const currentCentury = Math.floor(currentYear / 100) * 100;
            return y >= (currentYear % 100) ? currentCentury + y : currentCentury + 100 + y;
          }
          return y;
        };
        
        // Helper to remove ordinal suffixes (1st, 2nd, 3rd, 4th, etc.)
        const removeOrdinal = function(str) {
          return str.replace(/(\d+)(st|nd|rd|th)/i, '$1');
        };
        
        // Extract time from text (single time) - more flexible
        const extractTime = function(text) {
          // Try various patterns: "at 11 am", "11 am", "11:30 am", "at 11:30am", "6pm", "13:30", etc.
          // Avoid matching years (4-digit numbers) or dates
          const timePatterns = [
            // 24-hour format: "13:30", "14:00"
            /(\d{1,2}):(\d{2})\b/i,
            // 12-hour format with am/pm
            /at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            /(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            /(\d{1,2})(?::(\d{2}))?(am|pm)/i,  // No space: "6pm", "11:30am"
            // Without am/pm (less reliable)
            /at\s+(\d{1,2})(?::(\d{2}))?/i,
            /(\d{1,2})(?::(\d{2}))?/i
          ];
          
          for (const pattern of timePatterns) {
            const timeMatch = text.match(pattern);
            if (timeMatch) {
              const hour = parseInt(timeMatch[1]);
              const minute = parseInt(timeMatch[2] || '0');
              const ampm = timeMatch[3] || null;
              
              // Skip if it looks like a year (4-digit number) or if hour is too large
              if (hour > 23) continue;
              
              // If no am/pm and hour > 12, it might be 24-hour format
              if (!ampm && hour > 12 && hour <= 23 && minute <= 59) {
                return { hour, minute, ampm: null };
              }
              
              // If no am/pm and hour > 12, it's likely not a time
              if (!ampm && hour > 12) continue;
              
              // Validate hour (1-12 for 12-hour, 0-23 for 24-hour)
              if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59) {
                return { hour, minute, ampm };
              }
            }
          }
          
          return { hour: 12, minute: 0, ampm: null };
        };
        
        // Extract time range from text (from X to Y)
        const extractTimeRange = function(text) {
          // Patterns: "from 11 pm to 12 am", "11 pm to 12 am", "11pm-12am", "11:00 pm to 12:00 am"
          // Also: "at 11 to 14:00", "11 to 14:00" (24-hour format)
          const rangePatterns = [
            // 12-hour format with am/pm
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+to\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s*-\s*(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+until\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+through\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            // 24-hour format: "11 to 14:00", "at 11 to 14:00", "11:00 to 14:00"
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s+to\s+(\d{1,2})(?::(\d{2}))?/i,
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s*-\s*(\d{1,2})(?::(\d{2}))?/i,
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s+until\s+(\d{1,2})(?::(\d{2}))?/i,
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s+through\s+(\d{1,2})(?::(\d{2}))?/i
          ];
          
          for (const pattern of rangePatterns) {
            const match = text.match(pattern);
            if (match) {
              // Check if it's 24-hour format (no am/pm in match)
              const hasAmpm = match[3] && (match[3].toLowerCase() === 'am' || match[3].toLowerCase() === 'pm');
              
              if (hasAmpm) {
                // 12-hour format
                return {
                  start: {
                    hour: parseInt(match[1]),
                    minute: parseInt(match[2] || '0'),
                    ampm: match[3]
                  },
                  end: {
                    hour: parseInt(match[4]),
                    minute: parseInt(match[5] || '0'),
                    ampm: match[6]
                  }
                };
              } else {
                // 24-hour format
                const startHour = parseInt(match[1]);
                const startMinute = parseInt(match[2] || '0');
                const endHour = parseInt(match[3]);
                const endMinute = parseInt(match[4] || '0');
                
                // Validate 24-hour format (0-23 for hours, 0-59 for minutes)
                if (startHour >= 0 && startHour <= 23 && endHour >= 0 && endHour <= 23 &&
                    startMinute >= 0 && startMinute <= 59 && endMinute >= 0 && endMinute <= 59) {
                  return {
                    start: {
                      hour: startHour,
                      minute: startMinute,
                      ampm: null
                    },
                    end: {
                      hour: endHour,
                      minute: endMinute,
                      ampm: null
                    }
                  };
                }
              }
            }
          }
          
          return null;
        };
        
        // Patterns for common date/time expressions (ordered by specificity)
        const patterns = [
          // MM/DD/YYYY format: "11/10/2025 at 2pm", "11/10/25 at 2pm"
          {
            regex: /(\d{1,2})\s*\/\s*(\d{1,2})\s*\/\s*(\d{2,4})(?:\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?)?/i,
            handler: function(match) {
              const month = parseInt(match[1]) - 1; // JS months are 0-indexed
              const day = parseInt(match[2]);
              const year = parseYear(match[3]);
              let date = new Date(year, month, day, 12, 0, 0, 0);
              
              if (date < now && !match[3] || match[3].length === 2) {
                // If past date and 2-digit year, try next year
                if (match[3].length === 2) {
                  date = new Date(parseYear(match[3]), month, day, 12, 0, 0, 0);
                }
              }
              
              const timeRange = extractTimeRange(text);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                if (endDate <= startDate) endDate.setDate(endDate.getDate() + 1);
                return { start: { date: () => startDate }, end: { date: () => endDate } };
              }
              
              if (match[4]) {
                let hour = parseInt(match[4]);
                let minute = parseInt(match[5] || '0');
                if (match[6]) {
                  if (match[6].toLowerCase() === 'pm' && hour !== 12) hour += 12;
                  if (match[6].toLowerCase() === 'am' && hour === 12) hour = 0;
                }
                date.setHours(hour, minute, 0, 0);
              }
              
              return { start: { date: () => date }, text: match[0] };
            }
          },
          // Month before day with slashes: "nov / 19 / 2025", "nov/19/2025"
          {
            regex: /(\w{3,9})\s*\/\s*(\d{1,2})(?:st|nd|rd|th)?\s*\/\s*(\d{2,4})/i,
            handler: function(match) {
              const monthIdx = findMonth(match[1]);
              if (monthIdx < 0) return null;
              const day = parseInt(removeOrdinal(match[2]));
              const year = parseYear(match[3]);
              let date = new Date(year, monthIdx, day, 12, 0, 0, 0);
              
              const timeRange = extractTimeRange(text);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                if (endDate <= startDate) endDate.setDate(endDate.getDate() + 1);
                return { start: { date: () => startDate }, end: { date: () => endDate }, text: match[0] };
              }
              
              const time = extractTime(text);
              return this.parseTime(date, time.hour, time.minute, time.ampm);
            }
          },
          // Month before day: "nov 10 2025 6pm", "november 10 2025 6pm"
          {
            regex: /(\w{3,9})\s+(\d{1,2})(?:st|nd|rd|th)?(?:\s+(\d{2,4}))?(?:\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?)?/i,
            handler: function(match) {
              const monthIdx = findMonth(match[1]);
              if (monthIdx < 0) return null;
              const day = parseInt(removeOrdinal(match[2]));
              const year = match[3] ? parseYear(match[3]) : now.getFullYear();
              let date = new Date(year, monthIdx, day, 12, 0, 0, 0);
              
              if (!match[3] && date < now) {
                date = new Date(year + 1, monthIdx, day, 12, 0, 0, 0);
              }
              
              const timeRange = extractTimeRange(text);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                if (endDate <= startDate) endDate.setDate(endDate.getDate() + 1);
                return { start: { date: () => startDate }, end: { date: () => endDate }, text: match[0] };
              }
              
              if (match[4]) {
                let hour = parseInt(match[4]);
                let minute = parseInt(match[5] || '0');
                if (match[6]) {
                  if (match[6].toLowerCase() === 'pm' && hour !== 12) hour += 12;
                  if (match[6].toLowerCase() === 'am' && hour === 12) hour = 0;
                }
                date.setHours(hour, minute, 0, 0);
                return { start: { date: () => date }, text: match[0] };
              }
              
              const time = extractTime(text);
              return this.parseTime(date, time.hour, time.minute, time.ampm);
            }
          },
          // "tomorrow on 13:00" or "tomorrow on 13:30" - 24-hour format with "on"
          {
            regex: /tomorrow\s+on\s+(\d{1,2})(?::(\d{2}))?/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              const hour = parseInt(match[1]);
              const minute = parseInt(match[2] || '0');
              date.setHours(hour, minute, 0, 0);
              return { start: { date: () => date }, text: match[0] };
            }
          },
          // Day number before month (with or without year): "22 nov", "22 nov 2025", "22nd nov event at 11pm" - HIGH PRIORITY
          {
            regex: /(\d{1,2})(?:st|nd|rd|th)?\s+(\w{3,9})(?:\s+(\d{2,4}))?/i,
            handler: function(match) {
              // Check if second part is actually a month name
              const monthIdx = findMonth(match[2]);
              if (monthIdx < 0) return null; // Not a month, skip this pattern
              
              const day = parseInt(removeOrdinal(match[1]));
              const year = match[3] ? parseYear(match[3]) : now.getFullYear();
              // Create date at noon to avoid timezone issues causing day shift
              let date = new Date(year, monthIdx, day, 12, 0, 0, 0);
              
              // If date is in the past and no year was specified, try next year
              if (!match[3] && date < now) {
                date = new Date(year + 1, monthIdx, day, 12, 0, 0, 0);
              }
              
              // Check for time range
              const timeRange = extractTimeRange(text);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                
                if (endDate <= startDate) {
                  endDate.setDate(endDate.getDate() + 1);
                }
                
                return {
                  start: { date: () => startDate },
                  end: { date: () => endDate }
                };
              }
              
              // Single time - extract from text after the date part
              const datePart = match[0];
              const textAfterDate = text.substring(text.indexOf(datePart) + datePart.length);
              const time = extractTime(textAfterDate.length > 0 ? textAfterDate : text);
              if (!time || typeof time.hour !== 'number' || isNaN(time.hour)) {
                // Default to noon if no time found
                date.setHours(12, 0, 0, 0);
                return { start: { date: () => date } };
              }
              return this.parseTime(date, time.hour, time.minute, time.ampm);
            }
          },
          // "next [day]" before time range: "on next wednesday from 11 am to 12 pm" or "next wednesday at 11 to 14:00"
          {
            regex: /(?:on\s+)?next\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(?:at\s+|from\s+)?(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+to\s+(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              const startDate = new Date(date);
              const endDate = new Date(date);
              
              let startHour = parseInt(match[2]);
              let startMinute = parseInt(match[3] || '0');
              const startAmpm = match[4];
              
              if (startAmpm) {
                if (startAmpm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                if (startAmpm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
              }
              startDate.setHours(startHour, startMinute, 0, 0);
              
              let endHour = parseInt(match[5]);
              let endMinute = parseInt(match[6] || '0');
              const endAmpm = match[7];
              
              if (endAmpm) {
                if (endAmpm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                if (endAmpm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
              }
              endDate.setHours(endHour, endMinute, 0, 0);
              
              if (endDate <= startDate) {
                endDate.setDate(endDate.getDate() + 1);
              }
              
              return {
                start: { date: () => startDate },
                end: { date: () => endDate }
              };
            }
          },
          // Time range with "next [day]": "11 pm to 12 am on next wednesday" or "11 to 14:00 on next wednesday"
          {
            regex: /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+to\s+(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+(?:on\s+)?next\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[7].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              const startDate = new Date(date);
              const endDate = new Date(date);
              
              let startHour = parseInt(match[1]);
              let startMinute = parseInt(match[2] || '0');
              if (match[3]) {
                if (match[3].toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                if (match[3].toLowerCase() === 'am' && startHour === 12) startHour = 0;
              }
              startDate.setHours(startHour, startMinute, 0, 0);
              
              let endHour = parseInt(match[4]);
              let endMinute = parseInt(match[5] || '0');
              if (match[6]) {
                if (match[6].toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                if (match[6].toLowerCase() === 'am' && endHour === 12) endHour = 0;
              }
              endDate.setHours(endHour, endMinute, 0, 0);
              
              if (endDate <= startDate) {
                endDate.setDate(endDate.getDate() + 1);
              }
              
              return {
                start: { date: () => startDate },
                end: { date: () => endDate }
              };
            }
          },
          // "tomorrow" before time range: "tomorrow from 11 am to 12 pm" or "tomorrow at 11 to 14:00"
          {
            regex: /(?:on\s+)?tomorrow\s+(?:at\s+|from\s+)?(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+to\s+(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              
              const startDate = new Date(date);
              const endDate = new Date(date);
              
              let startHour = parseInt(match[1]);
              let startMinute = parseInt(match[2] || '0');
              const startAmpm = match[3];
              if (startAmpm) {
                if (startAmpm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                if (startAmpm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
              }
              startDate.setHours(startHour, startMinute, 0, 0);
              
              let endHour = parseInt(match[4]);
              let endMinute = parseInt(match[5] || '0');
              const endAmpm = match[6];
              if (endAmpm) {
                if (endAmpm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                if (endAmpm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
              }
              endDate.setHours(endHour, endMinute, 0, 0);
              
              if (endDate <= startDate) {
                endDate.setDate(endDate.getDate() + 1);
              }
              
              return {
                start: { date: () => startDate },
                end: { date: () => endDate }
              };
            }
          },
          // Time range with "tomorrow": "11 pm to 12 am tomorrow" or "11 to 14:00 tomorrow"
          {
            regex: /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+to\s+(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+(?:on\s+)?tomorrow/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              
              const startDate = new Date(date);
              const endDate = new Date(date);
              
              let startHour = parseInt(match[1]);
              let startMinute = parseInt(match[2] || '0');
              if (match[3]) {
                if (match[3].toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                if (match[3].toLowerCase() === 'am' && startHour === 12) startHour = 0;
              }
              startDate.setHours(startHour, startMinute, 0, 0);
              
              let endHour = parseInt(match[4]);
              let endMinute = parseInt(match[5] || '0');
              if (match[6]) {
                if (match[6].toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                if (match[6].toLowerCase() === 'am' && endHour === 12) endHour = 0;
              }
              endDate.setHours(endHour, endMinute, 0, 0);
              
              if (endDate <= startDate) {
                endDate.setDate(endDate.getDate() + 1);
              }
              
              return {
                start: { date: () => startDate },
                end: { date: () => endDate }
              };
            }
          },
          // "[event] at [time] tomorrow" - time before tomorrow
          {
            regex: /.*?\s+at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+tomorrow/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "[time] tomorrow" - time before tomorrow (without "at")
          {
            regex: /(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+tomorrow/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "tomorrow at 3pm" or "tomorrow [event] at 8pm"
          {
            regex: /tomorrow\s+(?:.*?\s+)?at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "tomorrow 3pm" or "tomorrow [event] 8pm" (without "at")
          {
            regex: /tomorrow\s+(?:.*?\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "tomorrow" (no time specified)
          {
            regex: /^tomorrow$/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              date.setHours(12, 0, 0, 0);
              return { start: { date: () => date } };
            }
          },
          // "next monday/tuesday/etc at 3pm"
          {
            regex: /next\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[2], match[3] || '0', match[4]);
            }
          },
          // Day name + ordinal + month: "friday 21st nov" or "friday 21st november"
          {
            regex: /(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(\d{1,2})(?:st|nd|rd|th)?\s+(\w{3,9})/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const dayName = match[1].toLowerCase();
              const day = parseInt(removeOrdinal(match[2]));
              const monthIdx = findMonth(match[3]);
              
              if (monthIdx < 0) return null;
              
              // Find the date that matches both day name and day number
              const currentYear = now.getFullYear();
              // Create date at noon to avoid timezone issues causing day shift
              let date = new Date(currentYear, monthIdx, day, 12, 0, 0, 0);
              
              // Adjust year if date is in the past
              if (date < now) {
                date = new Date(currentYear + 1, monthIdx, day, 12, 0, 0, 0);
              }
              
              // Verify day name matches
              const targetDay = dayNames.indexOf(dayName);
              while (date.getDay() !== targetDay) {
                date.setFullYear(date.getFullYear() + 1);
              }
              
              // Check for time range
              const timeRange = extractTimeRange(text);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                
                if (endDate <= startDate) {
                  endDate.setDate(endDate.getDate() + 1);
                }
                
                return {
                  start: { date: () => startDate },
                  end: { date: () => endDate }
                };
              }
              
              // Single time
              const time = extractTime(text);
              return this.parseTime(date, time.hour, time.minute, time.ampm);
            }
          },
          // Slash/dash/dot separated dates: 11/10/2025, 11-10-2025, 11.10.2025, nov/10/2025, nov / 10 / 2025, 28/11 (day/month)
          {
            regex: /(\w{3,9}|\d{1,2})\s*[\/\-\.,]\s*(\d{1,2})(?:st|nd|rd|th)?(?:\s*[\/\-\.,]\s*(\d{2,4}))?/i,
            handler: function(match) {
              let month, day, year;
              const part1 = match[1].toLowerCase();
              const part2 = parseInt(removeOrdinal(match[2]));
              const part3 = match[3];
              
              const monthIdx = findMonth(part1);
              if (monthIdx >= 0) {
                // Format: nov/10/2025 or nov / 10 / 2025
                month = monthIdx;
                day = part2;
                year = part3 ? parseYear(part3) : now.getFullYear();
              } else {
                // Format: 11/10/2025 (US format MM/DD/YYYY) or 10/11/2025 (DD/MM/YYYY) or 28/11 (DD/MM)
                const num1 = parseInt(part1);
                const num2 = part2;
                year = part3 ? parseYear(part3) : now.getFullYear();
                
                // If no year provided, check if it's likely DD/MM format (common in many countries)
                if (!part3) {
                  // Try DD/MM format first (28/11 means Nov 28)
                  if (num2 >= 1 && num2 <= 12 && num1 >= 1 && num1 <= 31) {
                    month = num2 - 1;
                    day = num1;
                  } else if (num1 >= 1 && num1 <= 12 && num2 >= 1 && num2 <= 31) {
                    // Try MM/DD format
                    month = num1 - 1;
                    day = num2;
                  } else {
                    return null;
                  }
                } else {
                  // Year provided - try US format first (MM/DD)
                  if (num1 >= 1 && num1 <= 12 && num2 >= 1 && num2 <= 31) {
                    month = num1 - 1;
                    day = num2;
                  } else if (num2 >= 1 && num2 <= 12 && num1 >= 1 && num1 <= 31) {
                    // Try DD/MM format
                    month = num2 - 1;
                    day = num1;
                  } else {
                    return null;
                  }
                }
              }
              
              // Create date at noon to avoid timezone issues causing day shift
              let date = new Date(year, month, day, 12, 0, 0, 0);
              
              // If date is in the past and no year was specified, try next year
              if (!part3 && date < now) {
                date = new Date(year + 1, month, day, 12, 0, 0, 0);
              }
              
              // Check for time range first
              const timeRange = extractTimeRange(text);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                
                // Parse start time
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  // 12-hour format
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                // If no ampm, it's already in 24-hour format
                startDate.setHours(startHour, startMinute, 0, 0);
                
                // Parse end time
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  // 12-hour format
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                // If no ampm, it's already in 24-hour format
                endDate.setHours(endHour, endMinute, 0, 0);
                
                // Handle case where end time is next day (e.g., 11 pm to 12 am or 23:00 to 01:00)
                if (endDate <= startDate) {
                  endDate.setDate(endDate.getDate() + 1);
                }
                
                return {
                  start: { date: () => startDate },
                  end: { date: () => endDate }
                };
              }
              
              // Single time
              const time = extractTime(text);
              return this.parseTime(date, time.hour, time.minute, time.ampm);
            }
          },
          // Month name with day (with or without year): "nov 10 2025", "november 10 2025", "nov 10th 2025", "22 nov", "nov 22"
          {
            regex: /(\w{3,9})\s+(\d{1,2})(?:st|nd|rd|th)?(?:\s+(\d{2,4}))?/i,
            handler: function(match) {
              try {
                const monthIdx = findMonth(match[1]);
                if (monthIdx < 0) return null;
                
                const day = parseInt(removeOrdinal(match[2]));
                const year = match[3] ? parseYear(match[3]) : now.getFullYear();
                // Create date at noon to avoid timezone issues causing day shift
                let date = new Date(year, monthIdx, day, 12, 0, 0, 0);
                
                // Validate date
                if (isNaN(date.getTime())) {
                  return null;
                }
                
                // If date is in the past and no year was specified, try next year
                if (!match[3] && date < now) {
                  date = new Date(year + 1, monthIdx, day, 12, 0, 0, 0);
                }
                
                // Check for time range
                const timeRange = extractTimeRange(text);
                if (timeRange) {
                  const startDate = new Date(date);
                  const endDate = new Date(date);
                  
                  let startHour = timeRange.start.hour;
                  let startMinute = timeRange.start.minute;
                  if (timeRange.start.ampm) {
                    if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                    if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                  }
                  startDate.setHours(startHour, startMinute, 0, 0);
                  
                  let endHour = timeRange.end.hour;
                  let endMinute = timeRange.end.minute;
                  if (timeRange.end.ampm) {
                    if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                    if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                  }
                  endDate.setHours(endHour, endMinute, 0, 0);
                  
                  if (endDate <= startDate) {
                    endDate.setDate(endDate.getDate() + 1);
                  }
                  
                  return {
                    start: { date: () => startDate },
                    end: { date: () => endDate }
                  };
                }
                
                // Single time - extract from text after the date part
                // Remove the matched date part to avoid matching year as time
                const datePart = match[0];
                const textAfterDate = text.substring(text.indexOf(datePart) + datePart.length);
                const time = extractTime(textAfterDate.length > 0 ? textAfterDate : text);
                if (!time || typeof time.hour !== 'number' || isNaN(time.hour)) {
                  // Default to noon if no time found
                  date.setHours(12, 0, 0, 0);
                  return { start: { date: () => date } };
                }
                // Use the extracted time - parseTime will handle am/pm conversion
                return this.parseTime(date, time.hour, time.minute, time.ampm);
              } catch (e) {
                console.error('Error in month name pattern handler:', e);
                return null;
              }
            }
          },
          // Ordinal day with month (with or without year): "10th nov 25", "10th november 2025", "22nd nov"
          {
            regex: /(\d{1,2})(?:st|nd|rd|th)\s+(\w{3,9})(?:\s+(\d{2,4}))?/i,
            handler: function(match) {
              const day = parseInt(removeOrdinal(match[1]));
              const monthIdx = findMonth(match[2]);
              if (monthIdx < 0) return null;
              
              const year = match[3] ? parseYear(match[3]) : now.getFullYear();
              // Create date at noon to avoid timezone issues causing day shift
              let date = new Date(year, monthIdx, day, 12, 0, 0, 0);
              
              // If date is in the past and no year was specified, try next year
              if (!match[3] && date < now) {
                date = new Date(year + 1, monthIdx, day, 12, 0, 0, 0);
              }
              
              // Check for time range
              const timeRange = extractTimeRange(text);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                
                if (endDate <= startDate) {
                  endDate.setDate(endDate.getDate() + 1);
                }
                
                return {
                  start: { date: () => startDate },
                  end: { date: () => endDate }
                };
              }
              
              const time = extractTime(text);
              return this.parseTime(date, time.hour, time.minute, time.ampm);
            }
          },
          // "Dec 25 2025 at 6pm" or "25 Dec 2025 6pm" or "december 25 2025"
          {
            regex: /(?:(\w{3,9})\s+)?(\d{1,2})(?:st|nd|rd|th)?(?:\s+(\w{3,9}))?\s+(\d{2,4})(?:\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?)?/i,
            handler: function(match) {
              let month, day, year, hour, minute, ampm;
              
              if (match[1]) {
                // "Dec 25 2025" or "november 10 2025"
                month = findMonth(match[1]);
                if (month < 0) return null;
                day = parseInt(removeOrdinal(match[2]));
                year = parseYear(match[4]);
                hour = parseInt(match[5] || '12');
                minute = parseInt(match[6] || '0');
                ampm = match[7];
              } else if (match[3]) {
                // "25 Dec 2025" or "10th nov 2025"
                day = parseInt(removeOrdinal(match[2]));
                month = findMonth(match[3]);
                if (month < 0) return null;
                year = parseYear(match[4]);
                hour = parseInt(match[5] || '12');
                minute = parseInt(match[6] || '0');
                ampm = match[7];
              } else {
                return null;
              }
              
              // Create date at noon to avoid timezone issues causing day shift
              const date = new Date(year, month, day, 12, 0, 0, 0);
              
              // Check for time range
              const timeRange = extractTimeRange(text);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                
                if (endDate <= startDate) {
                  endDate.setDate(endDate.getDate() + 1);
                }
                
                return {
                  start: { date: () => startDate },
                  end: { date: () => endDate }
                };
              }
              
              return this.parseTime(date, hour, minute, ampm);
            }
          },
          // "at [time] on [day]": "at 11 am on wednesday" or "at 11:30 am on wednesday" (high priority - common format)
          {
            regex: /at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[4].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              let hour = parseInt(match[1]);
              let minute = parseInt(match[2] || '0');
              const ampm = match[3];
              
              if (ampm) {
                if (ampm.toLowerCase() === 'pm' && hour !== 12) hour += 12;
                if (ampm.toLowerCase() === 'am' && hour === 12) hour = 0;
              }
              
              date.setHours(hour, minute, 0, 0);
              return { start: { date: () => date } };
            }
          },
          // "at [time] on [day]" with no space: "at 11am on wednesday" or "at 11:30am on wednesday"
          {
            regex: /at\s+(\d{1,2})(?::(\d{2}))?(am|pm)\s+on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[4].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              let hour = parseInt(match[1]);
              let minute = parseInt(match[2] || '0');
              const ampm = match[3];
              
              if (ampm) {
                if (ampm.toLowerCase() === 'pm' && hour !== 12) hour += 12;
                if (ampm.toLowerCase() === 'am' && hour === 12) hour = 0;
              }
              
              date.setHours(hour, minute, 0, 0);
              return { start: { date: () => date } };
            }
          },
          // "[time] on [day]": "11 am on wednesday" (without "at")
          {
            regex: /(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[4].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              let hour = parseInt(match[1]);
              let minute = parseInt(match[2] || '0');
              const ampm = match[3];
              
              if (ampm) {
                if (ampm.toLowerCase() === 'pm' && hour !== 12) hour += 12;
                if (ampm.toLowerCase() === 'am' && hour === 12) hour = 0;
              }
              
              date.setHours(hour, minute, 0, 0);
              return { start: { date: () => date } };
            }
          },
          // Day name before time range: "on wednesday from 11 am to 12 pm" or "wednesday at 11 to 14:00"
          {
            regex: /(?:on\s+)?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(?:at\s+|from\s+)?(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+to\s+(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              const startDate = new Date(date);
              const endDate = new Date(date);
              
              let startHour = parseInt(match[2]);
              let startMinute = parseInt(match[3] || '0');
              if (match[4]) {
                if (match[4].toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                if (match[4].toLowerCase() === 'am' && startHour === 12) startHour = 0;
              }
              startDate.setHours(startHour, startMinute, 0, 0);
              
              let endHour = parseInt(match[5]);
              let endMinute = parseInt(match[6] || '0');
              if (match[7]) {
                if (match[7].toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                if (match[7].toLowerCase() === 'am' && endHour === 12) endHour = 0;
              }
              endDate.setHours(endHour, endMinute, 0, 0);
              
              if (endDate <= startDate) {
                endDate.setDate(endDate.getDate() + 1);
              }
              
              return {
                start: { date: () => startDate },
                end: { date: () => endDate }
              };
            }
          },
          // Time range with day name: "11 pm to 12 am on wednesday" or "11 to 14:00 on wednesday"
          {
            regex: /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+to\s+(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+(?:on\s+)?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[7].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              const startDate = new Date(date);
              const endDate = new Date(date);
              
              let startHour = parseInt(match[1]);
              let startMinute = parseInt(match[2] || '0');
              if (match[3]) {
                if (match[3].toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                if (match[3].toLowerCase() === 'am' && startHour === 12) startHour = 0;
              }
              startDate.setHours(startHour, startMinute, 0, 0);
              
              let endHour = parseInt(match[4]);
              let endMinute = parseInt(match[5] || '0');
              if (match[6]) {
                if (match[6].toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                if (match[6].toLowerCase() === 'am' && endHour === 12) endHour = 0;
              }
              endDate.setHours(endHour, endMinute, 0, 0);
              
              if (endDate <= startDate) {
                endDate.setDate(endDate.getDate() + 1);
              }
              
              return {
                start: { date: () => startDate },
                end: { date: () => endDate }
              };
            }
          },
          // "on [day] [event] at [time]" - high priority for "on [day]" format
          {
            regex: /on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+.*?\s+at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[2], match[3] || '0', match[4]);
            }
          },
          // "[event] on [day] at [time]" or "[event] [day] at [time]"
          {
            regex: /(?:.*?\s+)?(?:on\s+)?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(?:.*?\s+)?at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[2], match[3] || '0', match[4]);
            }
          },
          // "[time] [event] on [day]" - e.g., "2 pm house party on wednesday"
          {
            regex: /(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+.*?\s+on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[4].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "friday 2:30pm" or "friday at 2:30pm" or "[event] friday 8pm"
          {
            regex: /(?:.*?\s+)?(?:on\s+)?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(?:.*?\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[2], match[3] || '0', match[4]);
            }
          },
          // "on [day] [event] at [time]" - specific pattern for "on [day]" format with event text
          {
            regex: /on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+.*?\s+at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[2], match[3] || '0', match[4]);
            }
          },
          // "on [day] at [time]" - direct format without event text
          {
            regex: /on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              // Set to noon first to avoid timezone issues
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[2], match[3] || '0', match[4]);
            }
          },
          // "today at [time]" or "today [event] at [time]"
          {
            regex: /today\s+(?:.*?\s+)?at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const date = new Date(now);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "today [time]" or "today [event] [time]"
          {
            regex: /today\s+(?:.*?\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const date = new Date(now);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "in 2 hours" or "2 hours from now"
          {
            regex: /(?:in\s+)?(\d+)\s+hours?\s+(?:from\s+now)?/i,
            handler: function(match) {
              const date = new Date(now);
              date.setHours(date.getHours() + parseInt(match[1]));
              return { start: { date: () => date } };
            }
          },
          // "in X minutes" or "X minutes from now"
          {
            regex: /(?:in\s+)?(\d+)\s+minutes?\s+(?:from\s+now)?/i,
            handler: function(match) {
              const date = new Date(now);
              date.setMinutes(date.getMinutes() + parseInt(match[1]));
              return { start: { date: () => date } };
            }
          },
          // "in X days" or "X days from now"
          {
            regex: /(?:in\s+)?(\d+)\s+days?\s+(?:from\s+now)?/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + parseInt(match[1]));
              const time = extractTime(text);
              return this.parseTime(date, time.hour, time.minute, time.ampm);
            }
          }
        ];
        
        // Try specific patterns first
        for (const pattern of patterns) {
          const match = text.match(pattern.regex);
          if (match) {
            try {
              const result = pattern.handler.call(this, match);
              if (result && result.start) return [result];
            } catch (e) {
              console.error('Parse error:', e);
            }
          }
        }
        
        // Fallback: Intelligent component-based parsing
        // Extract all date/time components and combine them intelligently
        const components = {
          dayName: null,
          month: null,
          day: null,
          year: null,
          time: null
        };
        
        // Extract day name (sunday, monday, etc.)
        const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        for (const day of dayNames) {
          if (textLower.includes(day)) {
            components.dayName = day;
            break;
          }
        }
        
        // Extract month (november, nov, etc.)
        for (let i = 0; i < months.length; i++) {
          if (textLower.includes(months[i]) || textLower.includes(monthAbbr[i])) {
            components.month = i;
            break;
          }
        }
        
        // Extract time with am/pm
        const timeWithAmpm = text.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i);
        if (timeWithAmpm) {
          const hour = parseInt(timeWithAmpm[1]);
          const minute = parseInt(timeWithAmpm[2] || '0');
          components.time = { hour, minute, ampm: timeWithAmpm[3] };
        }
        
        // Extract 24-hour time (13:30, 14:00, etc.) if no am/pm time found
        if (!components.time) {
          const time24 = text.match(/(\d{1,2}):(\d{2})\b/);
          if (time24) {
            const hour = parseInt(time24[1]);
            const minute = parseInt(time24[2]);
            if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59) {
              components.time = { hour, minute, ampm: null };
            }
          }
        }
        
        // Extract day number (1-31) - but avoid matching time hours
        const dayMatches = text.match(/\b(\d{1,2})(?:st|nd|rd|th)?\b/g);
        if (dayMatches) {
          for (const match of dayMatches) {
            const dayNum = parseInt(match.replace(/(st|nd|rd|th)/i, ''));
            // Skip if it's likely a time hour (1-12) and we already have a time
            if (dayNum >= 1 && dayNum <= 31 && (!components.time || dayNum > 12)) {
              components.day = dayNum;
              break;
            }
          }
        }
        
        // Extract year (4-digit)
        const yearMatch = text.match(/\b(20\d{2})\b/);
        if (yearMatch) {
          components.year = parseInt(yearMatch[1]);
        }
        
        // Combine components intelligently
        let finalDate = null;
        
        // Priority 1: If we have day name, use it
        if (components.dayName) {
          const targetDay = dayNames.indexOf(components.dayName);
          finalDate = new Date(now);
          const currentDay = finalDate.getDay();
          let daysAhead = targetDay - currentDay;
          if (daysAhead <= 0) daysAhead += 7;
          finalDate.setDate(finalDate.getDate() + daysAhead);
        } 
        // Priority 2: If we have month and day
        else if (components.month !== null && components.day) {
          // Create date at noon to avoid timezone issues causing day shift
          finalDate = new Date(components.year || now.getFullYear(), components.month, components.day, 12, 0, 0, 0);
          if (finalDate < now) {
            finalDate = new Date((components.year || now.getFullYear()) + 1, components.month, components.day, 12, 0, 0, 0);
          }
        }
        // Priority 3: Default to today
        else {
          finalDate = new Date(now);
        }
        
        // Apply time if found
        if (components.time) {
          return [this.parseTime(finalDate, components.time.hour, components.time.minute, components.time.ampm)];
        } else if (finalDate) {
          // Default to noon if no time specified
          finalDate.setHours(12, 0, 0, 0);
          return [{ start: { date: () => finalDate } }];
        }
        
        return [];
      },
      
      parseTime: function(date, hour, minute, ampm) {
        try {
          hour = parseInt(hour);
          minute = parseInt(minute || '0');
          
          // Validate inputs
          if (isNaN(hour) || hour < 0 || hour > 23) {
            hour = 12; // Default to noon
          }
          if (isNaN(minute) || minute < 0 || minute > 59) {
            minute = 0;
          }
          
          if (ampm) {
            if (ampm.toLowerCase() === 'pm' && hour !== 12) hour += 12;
            if (ampm.toLowerCase() === 'am' && hour === 12) hour = 0;
          } else {
            // If no am/pm specified:
            // - hour 12 means noon (12 PM), not midnight
            // - hours 1-11 default to PM
            // - hours 13-23 are already 24-hour format
            if (hour === 12) {
              // Noon - keep as 12 (12 PM)
              hour = 12;
            } else if (hour >= 1 && hour <= 11) {
              // Default to PM if no am/pm specified and hour 1-11
              hour += 12;
            }
            // Hours 13-23 are already in 24-hour format, leave as is
          }
          
          // Ensure hour is valid
          if (hour < 0) hour = 0;
          if (hour > 23) hour = 23;
          
          // Create a new date object to avoid mutating the original
          // Use the date's year, month, and day, but set the time
          const newDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), hour, minute, 0, 0);
          return { start: { date: () => newDate } };
        } catch (e) {
          console.error('Error in parseTime:', e);
          // Return default time
          const newDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0, 0);
          return { start: { date: () => newDate } };
        }
      }
    };
    
    // Make it available globally
    window.chrono = {
      parse: function(text, refDate, options) {
        return SimpleDateParser.parse(text, refDate);
      }
    };
    
    // Enable button immediately since we don't need external library
    window.addEventListener('load', function() {
      const btn = document.getElementById('generateBtn');
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = 'Generate Calendar Event';
      }
    });
  </script>
</head>
<body>
  <div class="container">
    <div class="header-section">
      <h1>Calendar Reminder</h1>
    </div>

    <div class="main-content">
      <div class="input-card">
        <label class="input-label">Your Reminder</label>
        <textarea 
          id="eventText" 
          placeholder="e.g., Team meeting tomorrow at 3pm in Conference Room A"
          autofocus
        ></textarea>
        <div class="button-group">
          <button id="generateBtn" onclick="generateCalendar()">
            Generate Event
          </button>
        </div>
        <div class="result" id="result"></div>
      </div>

      <div class="info-card">
        <div class="tip">
          <strong>Tip:</strong> Download the .ics file and open it in Google Calendar, Apple Calendar, Outlook, or any calendar app. The event will be added automatically!
        </div>

        <div class="examples">
          <h3>Examples</h3>
          <ul>
            <li>Doctor appointment next Monday at 10am</li>
            <li>Birthday party nov 10 2025 6pm</li>
            <li>Meeting 11/10/2025 at 2pm</li>
            <li>Gym session tomorrow 7am</li>
            <li>Conference call Friday 2:30pm</li>
            <li>Event 10th nov 25 at 3pm</li>
            <li>Party nov / 19 / 2025 from 11 pm to 12 am</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <script>
    // No need for loading checks - parser is built-in

    // Split text into multiple events (separated by newlines or common separators)
    function splitIntoEvents(text) {
      // Split by newlines first
      const lines = text.split(/\n+/).map(l => l.trim()).filter(l => l.length > 0);
      if (lines.length > 1) {
        return lines;
      }
      
      // Try splitting by common patterns: double newline, semicolon, or "and" followed by capital letter
      const parts = text.split(/\n\s*\n|;\s*|(?=\s+[A-Z][a-z]+\s+\w+\s+\d)/).map(p => p.trim()).filter(p => p.length > 0);
      if (parts.length > 1) {
        return parts;
      }
      
      // Single event
      return [text];
    }

    // Allow Enter key to submit (Ctrl/Cmd + Enter)
    document.getElementById('eventText').addEventListener('keydown', function(e) {
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        generateCalendar();
      }
    });

    function generateCalendar() {
      const text = document.getElementById("eventText").value.trim();
      const resultDiv = document.getElementById("result");
      const generateBtn = document.getElementById("generateBtn");

      resultDiv.innerHTML = "";
      generateBtn.disabled = true;
      generateBtn.innerHTML = '<span class="loading"></span>Processing...';

      // Check if text is empty
      if (!text) {
        resultDiv.innerHTML = '<div class="error">‚ö†Ô∏è Please describe your event or reminder.</div>';
        setTimeout(function() {
          generateBtn.disabled = false;
          generateBtn.innerHTML = 'Generate Event';
        }, 100);
        return;
      }

      // Parser is always available (built-in)

      try {
        const now = new Date();
        const eventTexts = splitIntoEvents(text);
        const allEvents = [];
        
        // Parse each event separately
        for (let i = 0; i < eventTexts.length; i++) {
          const eventText = eventTexts[i].trim();
          if (!eventText) continue;
          
          const results = chrono.parse(eventText, now, { forwardDate: true });

          if (!results || results.length === 0 || !results[0].start) {
            // Skip events that can't be parsed
            continue;
          }

          const parsedResult = results[0];
          const evStart = parsedResult.start.date();
          
          // Validate that the date is in the future or today
          if (evStart < new Date(now.getTime() - 60000)) {
            continue; // Skip past events
          }

          // Get end time
          let evEnd = null;
          let hasEnd = false;
          
          if (parsedResult.end && parsedResult.end.date()) {
            evEnd = parsedResult.end.date();
            hasEnd = true;
          } else {
            // Default: 1 hour duration
            evEnd = new Date(evStart.getTime() + 60 * 60 * 1000);
          }

          // Extract location if "at <location>" is present (but not "at [time]")
          let location = "";
          // More precise location extraction - avoid matching "at 11 am" as location
          const locPattern = /\bat\s+([A-Za-z0-9 ,.'-]+?)(?:\s+(?:on|next|tomorrow|today|monday|tuesday|wednesday|thursday|friday|saturday|sunday|\d{1,2}[:\d]{0,5}\s*(?:am|pm)|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|\d{4}|from|to))/i;
          const locMatch = eventText.match(locPattern);
          
          if (locMatch && locMatch[1]) {
            // Make sure it's not a time (like "at 11 am")
            const potentialLoc = locMatch[1].trim();
            if (!/^\d{1,2}(?::\d{2})?\s*(am|pm)$/i.test(potentialLoc)) {
              location = potentialLoc;
              // Clean up common false positives
              if (location.toLowerCase().match(/^(at|on|next|tomorrow|today|monday|tuesday|wednesday|thursday|friday|saturday|sunday)$/i)) {
                location = "";
              }
            }
          }

          // If no location found with "at", try other patterns
          if (!location) {
            const locPatterns = [
              /\bin\s+([A-Za-z0-9 ,.'-]+?)(?:\s+(?:at|on|next|tomorrow|today))/i,
              /\blocation[:\s]+([A-Za-z0-9 ,.'-]+)/i
            ];
            
            for (const pattern of locPatterns) {
              const match = eventText.match(pattern);
              if (match && match[1]) {
                location = match[1].trim();
                break;
              }
            }
          }

          // Extract summary (event title) - extract text BEFORE date/time patterns
          let summary = eventText;
          
          // Find where the date/time pattern starts in the text
          let dateTimeStart = eventText.length;
          if (parsedResult.text) {
            const dateTimeIndex = eventText.toLowerCase().indexOf(parsedResult.text.toLowerCase());
            if (dateTimeIndex >= 0) {
              dateTimeStart = dateTimeIndex;
            }
          }
          
          // Extract everything before the date/time as the title
          summary = eventText.substring(0, dateTimeStart).trim();
          
          // Remove common date/time keywords that might be at the start
          summary = summary.replace(/^(on|at|from|to|next|this|tomorrow|today|monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+/i, '');
          
          // Remove location patterns if found
          if (location) {
            summary = summary.replace(new RegExp(`\\s*at\\s+${location.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, 'i'), '');
            summary = summary.replace(new RegExp(`\\s*in\\s+${location.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, 'i'), '');
          }
          
          // Remove trailing date/time related words
          summary = summary.replace(/\s+(on|at|from|to|next|this|tomorrow|today)$/i, '');
          summary = summary.trim();

          // If summary is empty or too short, try extracting from original text differently
          if (!summary || summary.length < 2) {
            // Fallback: remove common date/time patterns from the full text
            summary = eventText
              .replace(/\b(next|this|tomorrow|today)\s+\w+/gi, '')
              .replace(/\b(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b/gi, '')
              .replace(/\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d+/gi, '')
              .replace(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/g, '')
              .replace(/\d{1,2}(st|nd|rd|th)?\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*/gi, '')
              .replace(/\d{1,2}(?::\d{2})?\s*(am|pm)/gi, '')
              .replace(/\d{1,2}:\d{2}/g, '')
              .replace(/\s+/g, ' ')
              .trim();
          }

          // If still empty, use a default
          if (!summary || summary.length < 2) {
            summary = "Event";
          }

          // Clean up summary
          summary = summary.replace(/\s+/g, ' ').trim();

          allEvents.push({
            summary: summary,
            start: evStart,
            end: evEnd,
            hasEnd: hasEnd,
            location: location,
            originalText: eventText
          });
        }
        
        if (allEvents.length === 0) {
          resultDiv.innerHTML = '<div class="error">‚ö†Ô∏è Could not extract date/time from your text.<br><br>Try being more specific:<br>‚Ä¢ "Meeting tomorrow at 3pm"<br>‚Ä¢ "Appointment Dec 15 2025 at 2:30pm"<br>‚Ä¢ "Event next Friday 10am"<br>‚Ä¢ "black friday 28/11 at 12 am"</div>';
          setTimeout(function() {
            generateBtn.disabled = false;
            generateBtn.innerHTML = 'Generate Event';
          }, 100);
          return;
        }

        // Generate ICS files for all events
        let html = '';
        
        for (let i = 0; i < allEvents.length; i++) {
          const event = allEvents[i];
          
          // ICS formatting - use floating time (no timezone) to avoid day shift
          function fmtICS(dt) {
            // Use local time components directly (floating time) to prevent timezone day shift
            const yyyy = dt.getFullYear();
            const mm = String(dt.getMonth() + 1).padStart(2, "0");
            const dd = String(dt.getDate()).padStart(2, "0");
            const h = String(dt.getHours()).padStart(2, "0");
            const m = String(dt.getMinutes()).padStart(2, "0");
            const s = String(dt.getSeconds()).padStart(2, "0");
            // No 'Z' suffix = floating time (local time, no timezone conversion)
            return `${yyyy}${mm}${dd}T${h}${m}${s}`;
          }

          const ics = 
            "BEGIN:VCALENDAR\nVERSION:2.0\nCALSCALE:GREGORIAN\n" +
            "BEGIN:VEVENT\n" +
            "SUMMARY:" + event.summary.replace(/\n/g," ") + "\n" +
            "DTSTART:" + fmtICS(event.start) + "\n" +
            "DTEND:" + fmtICS(event.end) + "\n" +
            (event.location ? "LOCATION:" + event.location.replace(/\n/g," ") + "\n" : "") +
            "DESCRIPTION:" + event.originalText.replace(/\n/g, " ") + "\n" +
            "END:VEVENT\nEND:VCALENDAR";

          // Generate Google Calendar URL
          const formatGoogleDate = (dt) => {
            return dt.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
          };
          const googleCalendarUrl = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(event.summary)}&dates=${formatGoogleDate(event.start)}/${formatGoogleDate(event.end)}${event.location ? '&location=' + encodeURIComponent(event.location) : ''}&details=${encodeURIComponent(event.originalText)}`;

          html += `
            <div class="event-summary" ${i > 0 ? 'style="margin-top: 1.5em;"' : ''}>
              <b>Event ${allEvents.length > 1 ? (i + 1) + ': ' : ''}${event.summary}</b><br>
              <b>Date & Time:</b> ${event.start.toLocaleString()}${event.hasEnd ? ' - ' + event.end.toLocaleString() : ''}<br>
              ${event.location ? '<b>Location:</b> ' + event.location + '<br>' : ''}
              <b>Description:</b> ${event.originalText}
            </div>
            <div style="display: flex; gap: 12px; flex-wrap: wrap; margin-top: 12px;">
              <a href="data:text/calendar;charset=utf8,${encodeURIComponent(ics)}" download="event${allEvents.length > 1 ? '-' + (i + 1) : ''}.ics" class="ics-link">
                ‚û°Ô∏è Download ICS
              </a>
              <a href="${googleCalendarUrl}" target="_blank" class="ics-link" style="background: #4285f4; color: white;">
                üìÖ Add to Google Calendar
              </a>
            </div>
          `;
        }
        
        if (allEvents.length > 1) {
          html = `<div style="margin-bottom: 1em; font-weight: bold; color: #727D73;">Found ${allEvents.length} events:</div>` + html;
        }

        resultDiv.innerHTML = html;
        setTimeout(function() {
          generateBtn.disabled = false;
          generateBtn.innerHTML = 'Generate Event';
        }, 100);

      } catch (error) {
        console.error('Error generating calendar:', error);
        console.error('Error stack:', error.stack);
        console.error('Input text:', text);
        resultDiv.innerHTML = '<div class="error">‚ö†Ô∏è An error occurred while processing your request.<br><br>Error: ' + (error.message || error.toString()) + '<br><br>Please check the browser console for more details.</div>';
        
        // Always reset button state
        setTimeout(function() {
          generateBtn.disabled = false;
          generateBtn.innerHTML = 'Generate Event';
        }, 100);
      }
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Auto-focus textarea on load
    window.addEventListener('load', function() {
      document.getElementById('eventText').focus();
    });

    // Make example items clickable - fill textarea when clicked
    document.querySelectorAll('.examples li').forEach(function(li) {
      li.addEventListener('click', function() {
        const text = this.textContent.trim();
        const textarea = document.getElementById('eventText');
        textarea.value = text;
        textarea.focus();
        // Add visual feedback
        this.style.transform = 'scale(0.95)';
        setTimeout(() => {
          this.style.transform = '';
        }, 150);
      });
    });
  </script>

  <div style="max-width: 1100px; margin: 60px auto 0; padding: 0 40px 60px;">
    <div style="background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 16px; padding: 40px; text-align: center;">
      <h3 style="font-size: 1.5rem; font-weight: 700; color: var(--text-primary); margin-bottom: 16px;">Shop NutriThrive Products</h3>
      <p style="color: var(--text-secondary); margin-bottom: 24px; font-size: 1rem;">Discover premium superfoods and wellness products:</p>
      <div style="display: flex; flex-wrap: wrap; gap: 12px; justify-content: center;">
        <a href="https://nutrithrive.com.au/pages/products/product-detail.html" style="background: var(--primary); color: white; border: none; padding: 12px 24px; border-radius: 8px; text-decoration: none; font-weight: 600; transition: all 0.3s;">Moringa Powder ‚Üí</a>
        <a href="https://nutrithrive.com.au/pages/products/product-curry-leaves.html" style="background: var(--primary); color: white; border: none; padding: 12px 24px; border-radius: 8px; text-decoration: none; font-weight: 600; transition: all 0.3s;">Curry Leaves ‚Üí</a>
        <a href="https://nutrithrive.com.au/pages/products/product-black-tea.html" style="background: var(--primary); color: white; border: none; padding: 12px 24px; border-radius: 8px; text-decoration: none; font-weight: 600; transition: all 0.3s;">Black Tea ‚Üí</a>
        <a href="https://nutrithrive.com.au/pages/products/products.html" style="background: transparent; color: var(--primary); border: 2px solid var(--primary); padding: 12px 24px; border-radius: 8px; text-decoration: none; font-weight: 600; transition: all 0.3s;">All Products ‚Üí</a>
      </div>
    </div>
  </div>
</body>
</html>

