<!DOCTYPE html>

<html lang="en">

<head>

  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>QuickCal_TERM_v3.0 | NutriThrive Labs</title>

  <link rel="icon" type="image/png" href="../../../assets/logo/scintilla.png">

  <link rel="apple-touch-icon" href="../../../assets/logo/scintilla.png">

  <link rel="shortcut icon" href="../../../assets/logo/scintilla.png">

  <!-- Font: JetBrains Mono (The ultimate dev font) -->

  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <style>

    

    /* --- TERMINAL RESET --- */

    * { box-sizing: border-box; margin: 0; padding: 0; outline: none; }



    :root {

      --bg: #0D0D0D;

      --surface: #1A1A1A;

      --border: #333333;

      --text-main: #E0E0E0;

      --text-dim: #666666;

      --accent: #FF4D00; /* Safety Orange */

      --accent-dim: rgba(255, 77, 0, 0.2);

      --success: #00FF41;

      --font-mono: 'JetBrains Mono', monospace;

    }

    body {

      font-family: var(--font-mono);

      background-color: var(--bg);

      color: var(--text-main);

      min-height: 100vh;

      display: flex;

      flex-direction: column;

      justify-content: flex-start;

      align-items: center;

      font-size: 14px;

      line-height: 1.5;

      padding: 40px 20px;

    }



    @media (max-width: 768px) {

      body {

        padding: 20px 10px;

        font-size: 13px;

      }

    }



    body::before {

      display: none;

    }



    body::after {

      display: none;

    }



    /* --- MAIN INTERFACE FRAME --- */

    .terminal-frame {

      width: 100%;

      max-width: 900px;

      min-height: 500px;

      background: var(--bg);

      border: 1px solid var(--border);

      display: grid;

      grid-template-rows: auto 1fr auto;

      box-shadow: 0 0 0 1px #000;

    }



    /* --- HEADER BAR --- */

    .header-bar {

      display: flex;

      justify-content: space-between;

      align-items: center;

      padding: 0.8rem 1.5rem;

      border-bottom: 1px solid var(--border);

      background: var(--surface);

      font-size: 0.8rem;

      text-transform: uppercase;

      letter-spacing: 0.1em;

    }



    .status-led {

      display: inline-block;

      width: 8px;

      height: 8px;

      background: var(--success);

      border-radius: 50%;

      margin-right: 8px;

      box-shadow: 0 0 5px var(--success);

    }



    /* --- WORKSPACE --- */

    .workspace {

      display: grid;

      grid-template-columns: 1fr 300px;

    }



    /* --- INPUT AREA --- */

    .input-area {

      padding: 2rem;

      display: flex;

      flex-direction: column;

      border-right: 1px solid var(--border);

    }



    .prompt-line {

      display: flex;

      gap: 1rem;

      margin-bottom: 1rem;

      color: var(--text-dim);

    }



    .prompt-symbol {

      color: var(--accent);

      font-weight: 700;

    }



    textarea {

      width: 100%;

      flex-grow: 1;

      background: transparent;

      border: none;

      color: var(--text-main);

      font-family: var(--font-mono);

      font-size: 1.1rem;

      resize: none;

      min-height: 200px;

      caret-color: var(--accent);

    }



    textarea::placeholder {

      color: #333;

    }



    /* --- SIDEBAR (CONTEXT) --- */

    .context-panel {

      background: #111;

      display: flex;

      flex-direction: column;

    }



    .panel-section {

      padding: 1.5rem;

      border-bottom: 1px solid var(--border);

    }



    .panel-label {

      font-size: 0.7rem;

      text-transform: uppercase;

      color: var(--text-dim);

      margin-bottom: 1rem;

      display: block;

    }



    .cmd-list {

      list-style: none;

      display: flex;

      flex-direction: column;

      gap: 0.5rem;

    }



    .cmd-item {

      cursor: pointer;

      padding: 0.5rem;

      border: 1px solid transparent;

      font-size: 0.85rem;

      color: #888;

      transition: all 0.1s;

    }



    .cmd-item:hover {

      background: var(--surface);

      border-color: var(--border);

      color: var(--text-main);

    }



    .cmd-item::before {

      content: '> ';

      color: var(--accent);

        opacity: 0;

      }



    .cmd-item:hover::before {

        opacity: 1;

    }



    /* --- ACTION FOOTER --- */

    .footer-bar {

      padding: 1rem 1.5rem;

      border-top: 1px solid var(--border);

      background: var(--surface);

      display: flex;

      justify-content: space-between;

      align-items: center;

    }



    button#generateBtn {

      background: var(--text-main);

      color: var(--bg);

      border: none;

      padding: 0.8rem 2rem;

      font-family: var(--font-mono);

      font-weight: 700;

      font-size: 0.9rem;

      text-transform: uppercase;

      cursor: pointer;

      transition: all 0.1s;

    }



    button#generateBtn:hover {

      background: var(--accent);

      color: var(--bg);

    }



    button#generateBtn:active {

      transform: translateY(2px);

    }



    button#generateBtn:disabled {

      opacity: 0.5;

      cursor: not-allowed;

    }



    .key-hint {

      font-size: 0.75rem;

      color: var(--text-dim);

      border: 1px solid var(--border);

      padding: 4px 8px;

      border-radius: 4px;

    }



    /* --- OUTPUT DISPLAY --- */

    .output-log {

      border-top: 1px solid var(--border);

      padding: 1.5rem;

      background: #000;

      font-size: 0.9rem;

      display: none;

    }



    .output-log.active {

      display: block;

    }



    .log-line {

      margin-bottom: 0.5rem;

      display: flex;

      gap: 1rem;

    }



    .log-ts { color: var(--text-dim); }



    .log-msg { color: var(--text-main); }



    .log-success { color: var(--success); }



    .log-error { color: var(--accent); }



    .result-actions {

      margin-top: 1.5rem;

      display: flex;

      gap: 1rem;

    }



    .res-link {

      color: var(--text-main);

      text-decoration: none;

      border: 1px solid var(--border);

      padding: 0.5rem 1rem;

      display: inline-block;

      transition: all 0.1s;

    }



    .res-link:hover {

      border-color: var(--accent);

      color: var(--accent);

    }



    /* Mobile */

    @media (max-width: 800px) {

      .workspace { 

        grid-template-columns: 1fr; 

      }

      .context-panel { 

        display: none; 

      }

    }



    @media (max-width: 768px) {

      .terminal-frame {

        max-width: 100%;

        min-height: auto;

        margin-bottom: 20px;

      }



      .header-bar {

        padding: 0.7rem 1rem;

        font-size: 0.7rem;

      }



      .header-bar span:last-child {

        font-size: 0.65rem;

      }



      .input-area {

        padding: 1.5rem 1rem;

      }



      .prompt-line {

        font-size: 0.85rem;

        margin-bottom: 0.8rem;

      }



      textarea {

        font-size: 1rem;

        min-height: 150px;

        padding: 1rem;

      }



      .footer-bar {

        padding: 0.8rem 1rem;

        flex-wrap: wrap;

        gap: 0.5rem;

      }



      button#generateBtn {

        width: 100%;

        padding: 0.9rem 1.5rem;

        font-size: 0.85rem;

      }



      .key-hint {

        font-size: 0.7rem;

        padding: 4px 8px;

      }



      .output-log {

        padding: 1rem;

        font-size: 0.85rem;

      }



      .log-line {

        flex-wrap: wrap;

        gap: 0.5rem;

      }



      .result-actions {

        flex-direction: column;

        gap: 0.5rem;

      }



      .res-link {

        width: 100%;

        text-align: center;

        padding: 0.7rem 1rem;

      }

    }



    @media (max-width: 480px) {

      body {

        padding: 15px 8px;

        font-size: 12px;

      }



      .terminal-frame {

        border-radius: 0;

      }



      .header-bar {

        padding: 0.6rem 0.8rem;

        font-size: 0.65rem;

      }



      .input-area {

        padding: 1rem 0.8rem;

      }



      textarea {

        font-size: 0.95rem;

        min-height: 120px;

      }



      .footer-bar {

        padding: 0.7rem 0.8rem;

      }



      button#generateBtn {

        padding: 0.85rem 1.2rem;

        font-size: 0.8rem;

      }



      /* Product Links Section Mobile */

      .product-links-section {

        margin-top: 30px !important;

        padding: 20px 10px !important;

      }



      .product-links-section > div {

        padding: 1.5rem 1rem !important;

      }



      .product-links-section h3 {

        font-size: 1rem !important;

        margin-bottom: 0.8rem !important;

      }



      .product-links-section p {

        font-size: 0.85rem !important;

        margin-bottom: 1.2rem !important;

      }



      .product-links-section a {

        padding: 10px 16px !important;

        font-size: 0.8rem !important;

        width: 100%;

        display: block;

        text-align: center;

        margin-bottom: 0.5rem;

      }

    }



    /* Product Links Mobile Styles */

    @media (max-width: 768px) {

      .product-links-section {

        margin-top: 30px !important;

        padding: 20px 10px !important;

      }



      .product-links-section > div {

        padding: 1.5rem 1rem !important;

      }



      .product-links-section h3 {

        font-size: 1.1rem !important;

        margin-bottom: 0.8rem !important;

      }



      .product-links-section p {

        font-size: 0.85rem !important;

        margin-bottom: 1.2rem !important;

      }



      .product-links-section > div > div:first-of-type {

        flex-direction: column !important;

        gap: 0.5rem !important;

      }



      .product-links-section > div > div:first-of-type a {

        width: 100% !important;

        padding: 12px 20px !important;

        font-size: 0.85rem !important;

      }



      .product-links-section > div > div:last-of-type > div {

        flex-direction: column !important;

        gap: 0.5rem !important;

      }



      .product-links-section > div > div:last-of-type a {

        width: 100% !important;

        padding: 10px 16px !important;

      }

    }



    @media (max-width: 480px) {

      .product-links-section {

        margin-top: 20px !important;

        padding: 15px 8px !important;

      }



      .product-links-section > div {

        padding: 1.2rem 0.8rem !important;

      }



      .product-links-section h3 {

        font-size: 1rem !important;

      }



      .product-links-section p {

        font-size: 0.8rem !important;

      }

    }



  </style>
  <script>
    // Enhanced date parser - handles many human-friendly formats
    const SimpleDateParser = {
      parse: function(text, refDate) {
        refDate = refDate || new Date();
        const now = new Date(refDate);
        const textLower = text.toLowerCase().trim();
        
        // Month names and abbreviations
        const months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];
        const monthAbbr = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
        
        // Helper to find month index
        const findMonth = function(monthStr) {
          if (!monthStr) return -1;
          const m = monthStr.toLowerCase();
          let idx = months.findIndex(month => month.startsWith(m));
          if (idx === -1) idx = monthAbbr.findIndex(abbr => abbr === m);
          return idx;
        };
        
        // Helper to parse year (handles 2-digit years)
        const parseYear = function(yearStr) {
          if (!yearStr) return now.getFullYear();
          const y = parseInt(yearStr);
          if (y < 100) {
            // 2-digit year: assume 20xx if >= current year - 2000, else 21xx
            const currentYear = now.getFullYear();
            const currentCentury = Math.floor(currentYear / 100) * 100;
            return y >= (currentYear % 100) ? currentCentury + y : currentCentury + 100 + y;
          }
          return y;
        };
        
        // Helper to remove ordinal suffixes (1st, 2nd, 3rd, 4th, etc.)
        const removeOrdinal = function(str) {
          return str.replace(/(\d+)(st|nd|rd|th)/i, '$1');
        };
        
        // Extract time from text (single time) - more flexible
        const extractTime = function(text) {
          // Try various patterns: "at 11 am", "11 am", "11:30 am", "at 11:30am", "6pm", "13:30", etc.
          // Avoid matching years (4-digit numbers) or dates
          const timePatterns = [
            // 24-hour format: "13:30", "14:00"
            /(\d{1,2}):(\d{2})\b/i,
            // 12-hour format with am/pm
            /at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            /(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            /(\d{1,2})(?::(\d{2}))?(am|pm)/i,  // No space: "6pm", "11:30am"
            // Without am/pm (less reliable)
            /at\s+(\d{1,2})(?::(\d{2}))?/i,
            /(\d{1,2})(?::(\d{2}))?/i
          ];
          
          for (const pattern of timePatterns) {
            const timeMatch = text.match(pattern);
            if (timeMatch) {
              const hour = parseInt(timeMatch[1]);
              const minute = parseInt(timeMatch[2] || '0');
              const ampm = timeMatch[3] || null;
              
              // Skip if it looks like a year (4-digit number) or if hour is too large
              if (hour > 23) continue;
              
              // If no am/pm and hour > 12, it might be 24-hour format
              if (!ampm && hour > 12 && hour <= 23 && minute <= 59) {
                return { hour, minute, ampm: null };
              }
              
              // If no am/pm and hour > 12, it's likely not a time
              if (!ampm && hour > 12) continue;
              
              // Validate hour (1-12 for 12-hour, 0-23 for 24-hour)
              if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59) {
                return { hour, minute, ampm };
              }
            }
          }
          
          return { hour: 12, minute: 0, ampm: null };
        };
        
        // Extract time range from text (from X to Y)
        const extractTimeRange = function(text) {
          // Patterns: "from 11 pm to 12 am", "11 pm to 12 am", "11pm-12am", "11:00 pm to 12:00 am"
          // Also: "at 11 to 14:00", "11 to 14:00" (24-hour format)
          const rangePatterns = [
            // 12-hour format with am/pm
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+to\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s*-\s*(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+until\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+through\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            // 24-hour format: "11 to 14:00", "at 11 to 14:00", "11:00 to 14:00"
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s+to\s+(\d{1,2})(?::(\d{2}))?/i,
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s*-\s*(\d{1,2})(?::(\d{2}))?/i,
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s+until\s+(\d{1,2})(?::(\d{2}))?/i,
            /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?\s+through\s+(\d{1,2})(?::(\d{2}))?/i
          ];
          
          for (const pattern of rangePatterns) {
            const match = text.match(pattern);
            if (match) {
              // Check if it's 24-hour format (no am/pm in match)
              const hasAmpm = match[3] && (match[3].toLowerCase() === 'am' || match[3].toLowerCase() === 'pm');
              
              if (hasAmpm) {
                // 12-hour format
                return {
                  start: {
                    hour: parseInt(match[1]),
                    minute: parseInt(match[2] || '0'),
                    ampm: match[3]
                  },
                  end: {
                    hour: parseInt(match[4]),
                    minute: parseInt(match[5] || '0'),
                    ampm: match[6]
                  }
                };
              } else {
                // 24-hour format
                const startHour = parseInt(match[1]);
                const startMinute = parseInt(match[2] || '0');
                const endHour = parseInt(match[3]);
                const endMinute = parseInt(match[4] || '0');
                
                // Validate 24-hour format (0-23 for hours, 0-59 for minutes)
                if (startHour >= 0 && startHour <= 23 && endHour >= 0 && endHour <= 23 &&
                    startMinute >= 0 && startMinute <= 59 && endMinute >= 0 && endMinute <= 59) {
                  return {
                    start: {
                      hour: startHour,
                      minute: startMinute,
                      ampm: null
                    },
                    end: {
                      hour: endHour,
                      minute: endMinute,
                      ampm: null
                    }
                  };
                }
              }
            }
          }
          
          return null;
        };
        
        // Patterns for common date/time expressions (ordered by specificity)
        const patterns = [
          // Month before day: "nov 10 2025 6pm", "november 10 2025 6pm", "Birthday party nov 10 2025 6pm"
          // Match month names specifically: jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec or full names
          // Allow text before the month name (removed \b to allow matching anywhere in text)
          // MOVED TO TOP for higher priority
          {
            regex: /(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\s+(\d{1,2})(?:st|nd|rd|th)?(?:\s+(\d{2,4}))?(?:\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?)?/i,
            handler: function(match, fullText) {
              const textToUse = fullText || text;
              const monthIdx = findMonth(match[1]);
              if (monthIdx < 0) return null;
              const day = parseInt(removeOrdinal(match[2]));
              const year = match[3] ? parseYear(match[3]) : now.getFullYear();
              let date = new Date(year, monthIdx, day, 12, 0, 0, 0);
              
              // Validate date
              if (isNaN(date.getTime())) return null;
              
              if (!match[3] && date < now) {
                date = new Date(year + 1, monthIdx, day, 12, 0, 0, 0);
              }
              
              const timeRange = extractTimeRange(textToUse);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                if (endDate <= startDate) endDate.setDate(endDate.getDate() + 1);
                return { start: { date: () => startDate }, end: { date: () => endDate }, text: match[0] };
              }
              
              if (match[4]) {
                let hour = parseInt(match[4]);
                let minute = parseInt(match[5] || '0');
                if (match[6]) {
                  if (match[6].toLowerCase() === 'pm' && hour !== 12) hour += 12;
                  if (match[6].toLowerCase() === 'am' && hour === 12) hour = 0;
                }
                date.setHours(hour, minute, 0, 0);
                return { start: { date: () => date }, text: match[0] };
              }
              
              const time = extractTime(textToUse);
              const result = this.parseTime(date, time.hour, time.minute, time.ampm);
              if (result) {
                result.text = match[0];
              }
              return result;
            }
          },
          // Month before day with slashes: "nov / 19 / 2025", "nov/19/2025", "Party nov / 19 / 2025 from 11 pm to 12 am"
          {
            regex: /(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\s*\/\s*(\d{1,2})(?:st|nd|rd|th)?\s*\/\s*(\d{2,4})/i,
            handler: function(match, fullText) {
              const textToUse = fullText || text;
              const monthIdx = findMonth(match[1]);
              if (monthIdx < 0) return null;
              const day = parseInt(removeOrdinal(match[2]));
              const year = parseYear(match[3]);
              let date = new Date(year, monthIdx, day, 12, 0, 0, 0);
              
              if (isNaN(date.getTime())) return null;
              
              const timeRange = extractTimeRange(textToUse);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                if (endDate <= startDate) endDate.setDate(endDate.getDate() + 1);
                return { start: { date: () => startDate }, end: { date: () => endDate }, text: match[0] };
              }
              
              const time = extractTime(textToUse);
              const result = this.parseTime(date, time.hour, time.minute, time.ampm);
              if (result) {
                result.text = match[0];
              }
              return result;
            }
          },
          // MM/DD/YYYY format: "11/10/2025 at 2pm", "11/10/25 at 2pm", "Meeting 11/10/2025 at 2pm"
          {
            regex: /(\d{1,2})\s*\/\s*(\d{1,2})\s*\/\s*(\d{2,4})(?:\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?)?/i,
            handler: function(match, fullText) {
              const textToUse = fullText || text;
              const month = parseInt(match[1]) - 1;
              const day = parseInt(match[2]);
              const year = parseYear(match[3]);
              let date = new Date(year, month, day, 12, 0, 0, 0);
              
              if (isNaN(date.getTime())) return null;
              
              const timeRange = extractTimeRange(textToUse);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                if (endDate <= startDate) endDate.setDate(endDate.getDate() + 1);
                return { start: { date: () => startDate }, end: { date: () => endDate }, text: match[0] };
              }
              
              if (match[4]) {
                let hour = parseInt(match[4]);
                let minute = parseInt(match[5] || '0');
                if (match[6]) {
                  if (match[6].toLowerCase() === 'pm' && hour !== 12) hour += 12;
                  if (match[6].toLowerCase() === 'am' && hour === 12) hour = 0;
                }
                date.setHours(hour, minute, 0, 0);
              }
              
              return { start: { date: () => date }, text: match[0] };
            }
          },
          // "tomorrow on 13:00" or "tomorrow on 13:30" - 24-hour format with "on"
          {
            regex: /tomorrow\s+on\s+(\d{1,2})(?::(\d{2}))?/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              const hour = parseInt(match[1]);
              const minute = parseInt(match[2] || '0');
              date.setHours(hour, minute, 0, 0);
              return { start: { date: () => date }, text: match[0] };
            }
          },
          // Day number before month (with or without year): "22 nov", "22 nov 2025", "22nd nov event at 11pm", "on 11 nov 2025"
          {
            regex: /(\d{1,2})(?:st|nd|rd|th)?\s+(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)(?:\s+(\d{2,4}))?(?:\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?)?/i,
            handler: function(match, fullText) {
              const textToUse = fullText || text;
              const monthIdx = findMonth(match[2]);
              if (monthIdx < 0) return null;
              
              const day = parseInt(removeOrdinal(match[1]));
              const year = match[3] ? parseYear(match[3]) : now.getFullYear();
              let date = new Date(year, monthIdx, day, 12, 0, 0, 0);
              
              if (!match[3] && date < now) {
                date = new Date(year + 1, monthIdx, day, 12, 0, 0, 0);
              }
              
              const timeRange = extractTimeRange(text);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                
                if (endDate <= startDate) {
                  endDate.setDate(endDate.getDate() + 1);
                }
                
                return {
                  start: { date: () => startDate },
                  end: { date: () => endDate }
                };
              }
              
              const datePart = match[0];
              const textAfterDate = text.substring(text.indexOf(datePart) + datePart.length);
              const time = extractTime(textAfterDate.length > 0 ? textAfterDate : text);
              if (!time || typeof time.hour !== 'number' || isNaN(time.hour)) {
                date.setHours(12, 0, 0, 0);
                return { start: { date: () => date } };
              }
              return this.parseTime(date, time.hour, time.minute, time.ampm);
            }
          },
          // "next [day]" before time range: "on next wednesday from 11 am to 12 pm" or "next wednesday at 11 to 14:00"
          {
            regex: /(?:on\s+)?next\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(?:at\s+|from\s+)?(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+to\s+(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              const startDate = new Date(date);
              const endDate = new Date(date);
              
              let startHour = parseInt(match[2]);
              let startMinute = parseInt(match[3] || '0');
              const startAmpm = match[4];
              
              if (startAmpm) {
                if (startAmpm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                if (startAmpm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
              }
              startDate.setHours(startHour, startMinute, 0, 0);
              
              let endHour = parseInt(match[5]);
              let endMinute = parseInt(match[6] || '0');
              const endAmpm = match[7];
              
              if (endAmpm) {
                if (endAmpm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                if (endAmpm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
              }
              endDate.setHours(endHour, endMinute, 0, 0);
              
              if (endDate <= startDate) {
                endDate.setDate(endDate.getDate() + 1);
              }
              
              return {
                start: { date: () => startDate },
                end: { date: () => endDate }
              };
            }
          },
          // Time range with "next [day]": "11 pm to 12 am on next wednesday" or "11 to 14:00 on next wednesday"
          {
            regex: /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+to\s+(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+(?:on\s+)?next\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[7].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              const startDate = new Date(date);
              const endDate = new Date(date);
              
              let startHour = parseInt(match[1]);
              let startMinute = parseInt(match[2] || '0');
              if (match[3]) {
                if (match[3].toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                if (match[3].toLowerCase() === 'am' && startHour === 12) startHour = 0;
              }
              startDate.setHours(startHour, startMinute, 0, 0);
              
              let endHour = parseInt(match[4]);
              let endMinute = parseInt(match[5] || '0');
              if (match[6]) {
                if (match[6].toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                if (match[6].toLowerCase() === 'am' && endHour === 12) endHour = 0;
              }
              endDate.setHours(endHour, endMinute, 0, 0);
              
              if (endDate <= startDate) {
                endDate.setDate(endDate.getDate() + 1);
              }
              
              return {
                start: { date: () => startDate },
                end: { date: () => endDate }
              };
            }
          },
          // "tomorrow" before time range: "tomorrow from 11 am to 12 pm" or "tomorrow at 11 to 14:00"
          {
            regex: /(?:on\s+)?tomorrow\s+(?:at\s+|from\s+)?(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+to\s+(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              
              const startDate = new Date(date);
              const endDate = new Date(date);
              
              let startHour = parseInt(match[1]);
              let startMinute = parseInt(match[2] || '0');
              const startAmpm = match[3];
              if (startAmpm) {
                if (startAmpm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                if (startAmpm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
              }
              startDate.setHours(startHour, startMinute, 0, 0);
              
              let endHour = parseInt(match[4]);
              let endMinute = parseInt(match[5] || '0');
              const endAmpm = match[6];
              if (endAmpm) {
                if (endAmpm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                if (endAmpm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
              }
              endDate.setHours(endHour, endMinute, 0, 0);
              
              if (endDate <= startDate) {
                endDate.setDate(endDate.getDate() + 1);
              }
              
              return {
                start: { date: () => startDate },
                end: { date: () => endDate }
              };
            }
          },
          // Time range with "tomorrow": "11 pm to 12 am tomorrow" or "11 to 14:00 tomorrow"
          {
            regex: /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+to\s+(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+(?:on\s+)?tomorrow/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              
              const startDate = new Date(date);
              const endDate = new Date(date);
              
              let startHour = parseInt(match[1]);
              let startMinute = parseInt(match[2] || '0');
              if (match[3]) {
                if (match[3].toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                if (match[3].toLowerCase() === 'am' && startHour === 12) startHour = 0;
              }
              startDate.setHours(startHour, startMinute, 0, 0);
              
              let endHour = parseInt(match[4]);
              let endMinute = parseInt(match[5] || '0');
              if (match[6]) {
                if (match[6].toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                if (match[6].toLowerCase() === 'am' && endHour === 12) endHour = 0;
              }
              endDate.setHours(endHour, endMinute, 0, 0);
              
              if (endDate <= startDate) {
                endDate.setDate(endDate.getDate() + 1);
              }
              
              return {
                start: { date: () => startDate },
                end: { date: () => endDate }
              };
            }
          },
          // "[event] at [time] tomorrow" - time before tomorrow
          {
            regex: /.*?\s+at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+tomorrow/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "[time] tomorrow" - time before tomorrow (without "at")
          {
            regex: /(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+tomorrow/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "tomorrow at 3pm" or "tomorrow [event] at 8pm"
          {
            regex: /tomorrow\s+(?:.*?\s+)?at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "tomorrow 3pm" or "tomorrow [event] 8pm" (without "at")
          {
            regex: /tomorrow\s+(?:.*?\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "tomorrow" (no time specified)
          {
            regex: /^tomorrow$/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + 1);
              date.setHours(12, 0, 0, 0);
              return { start: { date: () => date } };
            }
          },
          // "next monday/tuesday/etc at 3pm"
          {
            regex: /next\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[2], match[3] || '0', match[4]);
            }
          },
          // Day name + ordinal + month: "friday 21st nov" or "friday 21st november"
          {
            regex: /(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(\d{1,2})(?:st|nd|rd|th)?\s+(\w{3,9})/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const dayName = match[1].toLowerCase();
              const day = parseInt(removeOrdinal(match[2]));
              const monthIdx = findMonth(match[3]);
              
              if (monthIdx < 0) return null;
              
              const currentYear = now.getFullYear();
              let date = new Date(currentYear, monthIdx, day, 12, 0, 0, 0);
              
              if (date < now) {
                date = new Date(currentYear + 1, monthIdx, day, 12, 0, 0, 0);
              }
              
              const targetDay = dayNames.indexOf(dayName);
              while (date.getDay() !== targetDay) {
                date.setFullYear(date.getFullYear() + 1);
              }
              
              const timeRange = extractTimeRange(text);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                
                if (endDate <= startDate) {
                  endDate.setDate(endDate.getDate() + 1);
                }
                
                return {
                  start: { date: () => startDate },
                  end: { date: () => endDate }
                };
              }
              
              const time = extractTime(text);
              return this.parseTime(date, time.hour, time.minute, time.ampm);
            }
          },
          // Slash/dash/dot separated dates: 11/10/2025, 11-10-2025, 11.10.2025, nov/10/2025, nov / 10 / 2025, 28/11 (day/month)
          {
            regex: /((?:jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)|\d{1,2})\s*[\/\-\.,]\s*(\d{1,2})(?:st|nd|rd|th)?(?:\s*[\/\-\.,]\s*(\d{2,4}))?(?:\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?)?/i,
            handler: function(match, fullText) {
              const textToUse = fullText || text;
              let month, day, year;
              const part1 = match[1].toLowerCase();
              const part2 = parseInt(removeOrdinal(match[2]));
              const part3 = match[3];
              
              const monthIdx = findMonth(part1);
              if (monthIdx >= 0) {
                month = monthIdx;
                day = part2;
                year = part3 ? parseYear(part3) : now.getFullYear();
              } else {
                const num1 = parseInt(part1);
                const num2 = part2;
                year = part3 ? parseYear(part3) : now.getFullYear();
                
                if (!part3) {
                  if (num2 >= 1 && num2 <= 12 && num1 >= 1 && num1 <= 31) {
                    month = num2 - 1;
                    day = num1;
                  } else if (num1 >= 1 && num1 <= 12 && num2 >= 1 && num2 <= 31) {
                    month = num1 - 1;
                    day = num2;
                  } else {
                    return null;
                  }
                } else {
                  if (num1 >= 1 && num1 <= 12 && num2 >= 1 && num2 <= 31) {
                    month = num1 - 1;
                    day = num2;
                  } else if (num2 >= 1 && num2 <= 12 && num1 >= 1 && num1 <= 31) {
                    month = num2 - 1;
                    day = num1;
                  } else {
                    return null;
                  }
                }
              }
              
              let date = new Date(year, month, day, 12, 0, 0, 0);
              
              if (isNaN(date.getTime())) return null;
              
              if (match[4]) {
                let hour = parseInt(match[4]);
                let minute = parseInt(match[5] || '0');
                if (match[6]) {
                  if (match[6].toLowerCase() === 'pm' && hour !== 12) hour += 12;
                  if (match[6].toLowerCase() === 'am' && hour === 12) hour = 0;
                }
                date.setHours(hour, minute, 0, 0);
                return { start: { date: () => date }, text: match[0] };
              }
              
              if (!part3 && date < now) {
                date = new Date(year + 1, month, day, 12, 0, 0, 0);
              }
              
              const timeRange = extractTimeRange(textToUse);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                
                if (endDate <= startDate) {
                  endDate.setDate(endDate.getDate() + 1);
                }
                
                return {
                  start: { date: () => startDate },
                  end: { date: () => endDate },
                  text: match[0]
                };
              }
              
              const time = extractTime(text);
              const result = this.parseTime(date, time.hour, time.minute, time.ampm);
              if (result) {
                result.text = match[0];
              }
              return result;
            }
          },
          // Month name with day (with or without year): "nov 10 2025", "november 10 2025", "nov 10th 2025", "22 nov", "nov 22"
          {
            regex: /(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\s+(\d{1,2})(?:st|nd|rd|th)?(?:\s+(\d{2,4}))?/i,
            handler: function(match) {
              try {
                const monthIdx = findMonth(match[1]);
                if (monthIdx < 0) return null;
                
                const day = parseInt(removeOrdinal(match[2]));
                const year = match[3] ? parseYear(match[3]) : now.getFullYear();
                let date = new Date(year, monthIdx, day, 12, 0, 0, 0);
                
                if (isNaN(date.getTime())) {
                  return null;
                }
                
                if (!match[3] && date < now) {
                  date = new Date(year + 1, monthIdx, day, 12, 0, 0, 0);
                }
                
                const timeRange = extractTimeRange(text);
                if (timeRange) {
                  const startDate = new Date(date);
                  const endDate = new Date(date);
                  
                  let startHour = timeRange.start.hour;
                  let startMinute = timeRange.start.minute;
                  if (timeRange.start.ampm) {
                    if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                    if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                  }
                  startDate.setHours(startHour, startMinute, 0, 0);
                  
                  let endHour = timeRange.end.hour;
                  let endMinute = timeRange.end.minute;
                  if (timeRange.end.ampm) {
                    if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                    if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                  }
                  endDate.setHours(endHour, endMinute, 0, 0);
                  
                  if (endDate <= startDate) {
                    endDate.setDate(endDate.getDate() + 1);
                  }
                  
                  return {
                    start: { date: () => startDate },
                    end: { date: () => endDate }
                  };
                }
                
                const datePart = match[0];
                const textAfterDate = text.substring(text.indexOf(datePart) + datePart.length);
                const time = extractTime(textAfterDate.length > 0 ? textAfterDate : text);
                if (!time || typeof time.hour !== 'number' || isNaN(time.hour)) {
                  date.setHours(12, 0, 0, 0);
                  return { start: { date: () => date } };
                }
                const result = this.parseTime(date, time.hour, time.minute, time.ampm);
                if (result) {
                  result.text = match[0];
                }
                return result;
              } catch (e) {
                console.error('Error in month name pattern handler:', e);
                return null;
              }
            }
          },
          // Ordinal day with month (with or without year): "10th nov 25", "10th november 2025", "22nd nov", "Event 10th nov 25 at 3pm"
          {
            regex: /(\d{1,2})(?:st|nd|rd|th)\s+(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)(?:\s+(\d{2,4}))?(?:\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?)?/i,
            handler: function(match) {
              const day = parseInt(removeOrdinal(match[1]));
              const monthIdx = findMonth(match[2]);
              if (monthIdx < 0) return null;
              
              const year = match[3] ? parseYear(match[3]) : now.getFullYear();
              let date = new Date(year, monthIdx, day, 12, 0, 0, 0);
              
              if (isNaN(date.getTime())) return null;
              
              if (!match[3] && date < now) {
                date = new Date(year + 1, monthIdx, day, 12, 0, 0, 0);
              }
              
              const timeRange = extractTimeRange(text);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                
                if (endDate <= startDate) {
                  endDate.setDate(endDate.getDate() + 1);
                }
                
                return {
                  start: { date: () => startDate },
                  end: { date: () => endDate },
                  text: match[0]
                };
              }
              
              if (match[4]) {
                let hour = parseInt(match[4]);
                let minute = parseInt(match[5] || '0');
                if (match[6]) {
                  if (match[6].toLowerCase() === 'pm' && hour !== 12) hour += 12;
                  if (match[6].toLowerCase() === 'am' && hour === 12) hour = 0;
                }
                date.setHours(hour, minute, 0, 0);
                return { start: { date: () => date }, text: match[0] };
              }
              
              const time = extractTime(text);
              const result = this.parseTime(date, time.hour, time.minute, time.ampm);
              if (result) {
                result.text = match[0];
              }
              return result;
            }
          },
          // "Dec 25 2025 at 6pm" or "25 Dec 2025 6pm" or "december 25 2025"
          {
            regex: /(?:(\w{3,9})\s+)?(\d{1,2})(?:st|nd|rd|th)?(?:\s+(\w{3,9}))?\s+(\d{2,4})(?:\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?)?/i,
            handler: function(match) {
              let month, day, year, hour, minute, ampm;
              
              if (match[1]) {
                month = findMonth(match[1]);
                if (month < 0) return null;
                day = parseInt(removeOrdinal(match[2]));
                year = parseYear(match[4]);
                hour = parseInt(match[5] || '12');
                minute = parseInt(match[6] || '0');
                ampm = match[7];
              } else if (match[3]) {
                day = parseInt(removeOrdinal(match[2]));
                month = findMonth(match[3]);
                if (month < 0) return null;
                year = parseYear(match[4]);
                hour = parseInt(match[5] || '12');
                minute = parseInt(match[6] || '0');
                ampm = match[7];
              } else {
                return null;
              }
              
              const date = new Date(year, month, day, 12, 0, 0, 0);
              
              const timeRange = extractTimeRange(text);
              if (timeRange) {
                const startDate = new Date(date);
                const endDate = new Date(date);
                
                let startHour = timeRange.start.hour;
                let startMinute = timeRange.start.minute;
                if (timeRange.start.ampm) {
                  if (timeRange.start.ampm.toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                  if (timeRange.start.ampm.toLowerCase() === 'am' && startHour === 12) startHour = 0;
                }
                startDate.setHours(startHour, startMinute, 0, 0);
                
                let endHour = timeRange.end.hour;
                let endMinute = timeRange.end.minute;
                if (timeRange.end.ampm) {
                  if (timeRange.end.ampm.toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                  if (timeRange.end.ampm.toLowerCase() === 'am' && endHour === 12) endHour = 0;
                }
                endDate.setHours(endHour, endMinute, 0, 0);
                
                if (endDate <= startDate) {
                  endDate.setDate(endDate.getDate() + 1);
                }
                
                return {
                  start: { date: () => startDate },
                  end: { date: () => endDate }
                };
              }
              
              return this.parseTime(date, hour, minute, ampm);
            }
          },
          // "at [time] on [day]": "at 11 am on wednesday" or "at 11:30 am on wednesday" (high priority - common format)
          {
            regex: /at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[4].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              let hour = parseInt(match[1]);
              let minute = parseInt(match[2] || '0');
              const ampm = match[3];
              
              if (ampm) {
                if (ampm.toLowerCase() === 'pm' && hour !== 12) hour += 12;
                if (ampm.toLowerCase() === 'am' && hour === 12) hour = 0;
              }
              
              date.setHours(hour, minute, 0, 0);
              return { start: { date: () => date } };
            }
          },
          // "at [time] on [day]" with no space: "at 11am on wednesday" or "at 11:30am on wednesday"
          {
            regex: /at\s+(\d{1,2})(?::(\d{2}))?(am|pm)\s+on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[4].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              let hour = parseInt(match[1]);
              let minute = parseInt(match[2] || '0');
              const ampm = match[3];
              
              if (ampm) {
                if (ampm.toLowerCase() === 'pm' && hour !== 12) hour += 12;
                if (ampm.toLowerCase() === 'am' && hour === 12) hour = 0;
              }
              
              date.setHours(hour, minute, 0, 0);
              return { start: { date: () => date } };
            }
          },
          // "[time] on [day]": "11 am on wednesday" (without "at")
          {
            regex: /(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[4].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              let hour = parseInt(match[1]);
              let minute = parseInt(match[2] || '0');
              const ampm = match[3];
              
              if (ampm) {
                if (ampm.toLowerCase() === 'pm' && hour !== 12) hour += 12;
                if (ampm.toLowerCase() === 'am' && hour === 12) hour = 0;
              }
              
              date.setHours(hour, minute, 0, 0);
              return { start: { date: () => date } };
            }
          },
          // Day name before time range: "on wednesday from 11 am to 12 pm" or "wednesday at 11 to 14:00"
          {
            regex: /(?:on\s+)?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(?:at\s+|from\s+)?(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+to\s+(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              const startDate = new Date(date);
              const endDate = new Date(date);
              
              let startHour = parseInt(match[2]);
              let startMinute = parseInt(match[3] || '0');
              if (match[4]) {
                if (match[4].toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                if (match[4].toLowerCase() === 'am' && startHour === 12) startHour = 0;
              }
              startDate.setHours(startHour, startMinute, 0, 0);
              
              let endHour = parseInt(match[5]);
              let endMinute = parseInt(match[6] || '0');
              if (match[7]) {
                if (match[7].toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                if (match[7].toLowerCase() === 'am' && endHour === 12) endHour = 0;
              }
              endDate.setHours(endHour, endMinute, 0, 0);
              
              if (endDate <= startDate) {
                endDate.setDate(endDate.getDate() + 1);
              }
              
              return {
                start: { date: () => startDate },
                end: { date: () => endDate }
              };
            }
          },
          // Time range with day name: "11 pm to 12 am on wednesday" or "11 to 14:00 on wednesday"
          {
            regex: /(?:from\s+|at\s+)?(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+to\s+(\d{1,2})(?::(\d{2}))?(?:\s*(am|pm))?\s+(?:on\s+)?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[7].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              
              const startDate = new Date(date);
              const endDate = new Date(date);
              
              let startHour = parseInt(match[1]);
              let startMinute = parseInt(match[2] || '0');
              if (match[3]) {
                if (match[3].toLowerCase() === 'pm' && startHour !== 12) startHour += 12;
                if (match[3].toLowerCase() === 'am' && startHour === 12) startHour = 0;
              }
              startDate.setHours(startHour, startMinute, 0, 0);
              
              let endHour = parseInt(match[4]);
              let endMinute = parseInt(match[5] || '0');
              if (match[6]) {
                if (match[6].toLowerCase() === 'pm' && endHour !== 12) endHour += 12;
                if (match[6].toLowerCase() === 'am' && endHour === 12) endHour = 0;
              }
              endDate.setHours(endHour, endMinute, 0, 0);
              
              if (endDate <= startDate) {
                endDate.setDate(endDate.getDate() + 1);
              }
              
              return {
                start: { date: () => startDate },
                end: { date: () => endDate }
              };
            }
          },
          // "on [day] [event] at [time]" - high priority for "on [day]" format
          {
            regex: /on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+.*?\s+at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[2], match[3] || '0', match[4]);
            }
          },
          // "[event] on [day] at [time]" or "[event] [day] at [time]"
          {
            regex: /(?:.*?\s+)?(?:on\s+)?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(?:.*?\s+)?at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[2], match[3] || '0', match[4]);
            }
          },
          // "[time] [event] on [day]" - e.g., "2 pm house party on wednesday"
          {
            regex: /(\d{1,2})(?::(\d{2}))?\s*(am|pm)\s+.*?\s+on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[4].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "friday 2:30pm" or "friday at 2:30pm" or "[event] friday 8pm"
          {
            regex: /(?:.*?\s+)?(?:on\s+)?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+(?:.*?\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[2], match[3] || '0', match[4]);
            }
          },
          // "on [day] [event] at [time]" - specific pattern for "on [day]" format with event text
          {
            regex: /on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+.*?\s+at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[2], match[3] || '0', match[4]);
            }
          },
          // "on [day] at [time]" - direct format without event text
          {
            regex: /on\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
              const targetDay = dayNames.indexOf(match[1].toLowerCase());
              const date = new Date(now);
              date.setHours(12, 0, 0, 0);
              const currentDay = date.getDay();
              let daysAhead = targetDay - currentDay;
              if (daysAhead <= 0) daysAhead += 7;
              date.setDate(date.getDate() + daysAhead);
              return this.parseTime(date, match[2], match[3] || '0', match[4]);
            }
          },
          // "today at [time]" or "today [event] at [time]"
          {
            regex: /today\s+(?:.*?\s+)?at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const date = new Date(now);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "today [time]" or "today [event] [time]"
          {
            regex: /today\s+(?:.*?\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const date = new Date(now);
              return this.parseTime(date, match[1], match[2] || '0', match[3]);
            }
          },
          // "in 2 hours" or "2 hours from now"
          {
            regex: /(?:in\s+)?(\d+)\s+hours?\s+(?:from\s+now)?/i,
            handler: function(match) {
              const date = new Date(now);
              date.setHours(date.getHours() + parseInt(match[1]));
              return { start: { date: () => date } };
            }
          },
          // "in X minutes" or "X minutes from now"
          {
            regex: /(?:in\s+)?(\d+)\s+minutes?\s+(?:from\s+now)?/i,
            handler: function(match) {
              const date = new Date(now);
              date.setMinutes(date.getMinutes() + parseInt(match[1]));
              return { start: { date: () => date } };
            }
          },
          // "on 27th next month at 11 am" or "27th next month at 11 am" - ordinal day with "next month"
          {
            regex: /(?:on\s+)?(\d{1,2})(?:st|nd|rd|th)\s+next\s+month\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const day = parseInt(removeOrdinal(match[1]));
              const currentMonth = now.getMonth();
              const currentYear = now.getFullYear();
              
              let date = new Date(currentYear, currentMonth + 1, day, 12, 0, 0, 0);
              
              let hour = parseInt(match[2]);
              let minute = parseInt(match[3] || '0');
              const ampm = match[4];
              if (ampm) {
                if (ampm.toLowerCase() === 'pm' && hour !== 12) hour += 12;
                if (ampm.toLowerCase() === 'am' && hour === 12) hour = 0;
              }
              date.setHours(hour, minute, 0, 0);
              
              return { start: { date: () => date }, text: match[0] };
            }
          },
          // "next month on 27th at 11 am" or "next month 27th at 11 am" - "next month" before ordinal day
          {
            regex: /next\s+month\s+(?:on\s+)?(\d{1,2})(?:st|nd|rd|th)\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const day = parseInt(removeOrdinal(match[1]));
              const currentMonth = now.getMonth();
              const currentYear = now.getFullYear();
              
              let date = new Date(currentYear, currentMonth + 1, day, 12, 0, 0, 0);
              
              let hour = parseInt(match[2]);
              let minute = parseInt(match[3] || '0');
              const ampm = match[4];
              if (ampm) {
                if (ampm.toLowerCase() === 'pm' && hour !== 12) hour += 12;
                if (ampm.toLowerCase() === 'am' && hour === 12) hour = 0;
              }
              date.setHours(hour, minute, 0, 0);
              
              return { start: { date: () => date }, text: match[0] };
            }
          },
          // "in X days" or "X days from now"
          {
            regex: /(?:in\s+)?(\d+)\s+days?\s+(?:from\s+now)?/i,
            handler: function(match) {
              const date = new Date(now);
              date.setDate(date.getDate() + parseInt(match[1]));
              const time = extractTime(text);
              return this.parseTime(date, time.hour, time.minute, time.ampm);
            }
          },
          // "on 27th at 11 am" or "27th at 11 am" - ordinal day without month (defaults to current month)
          {
            regex: /(?:on\s+)?(\d{1,2})(?:st|nd|rd|th)\s+(?!next\s+month)(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match) {
              const day = parseInt(removeOrdinal(match[1]));
              const currentMonth = now.getMonth();
              const currentYear = now.getFullYear();
              
              let date = new Date(currentYear, currentMonth, day, 12, 0, 0, 0);
              
              if (date < now) {
                date = new Date(currentYear, currentMonth + 1, day, 12, 0, 0, 0);
              }
              
              let hour = parseInt(match[2]);
              let minute = parseInt(match[3] || '0');
              const ampm = match[4];
              if (ampm) {
                if (ampm.toLowerCase() === 'pm' && hour !== 12) hour += 12;
                if (ampm.toLowerCase() === 'am' && hour === 12) hour = 0;
              }
              date.setHours(hour, minute, 0, 0);
              
              return { start: { date: () => date }, text: match[0] };
            }
          },
          // "Event at 10am" or "[anything] at [time]" - time only, default to today
          {
            regex: /at\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i,
            handler: function(match, fullText) {
              const textToUse = fullText || text;
              if (/next\s+month/i.test(textToUse)) {
                return null;
              }
              const date = new Date(now);
              let hour = parseInt(match[1]);
              let minute = parseInt(match[2] || '0');
              const ampm = match[3];
              if (ampm) {
                if (ampm.toLowerCase() === 'pm' && hour !== 12) hour += 12;
                if (ampm.toLowerCase() === 'am' && hour === 12) hour = 0;
              }
              date.setHours(hour, minute, 0, 0);
              if (date < now) {
                date.setDate(date.getDate() + 1);
              }
              return { start: { date: () => date }, text: match[0] };
            }
          }
        ];
        
        // Normalize text: replace newlines with spaces and clean up whitespace
        const normalizedText = text.replace(/\s+/g, ' ').trim();
        
        // Try specific patterns first
        for (let i = 0; i < patterns.length; i++) {
          const pattern = patterns[i];
          let match = normalizedText.match(pattern.regex);
          if (!match) {
            match = text.match(pattern.regex);
          }
          if (match) {
            try {
              const result = pattern.handler.call(this, match, normalizedText);
              if (result && result.start) {
                if (!result.text) {
                  result.text = match[0];
                }
                return [result];
              }
            } catch (e) {
              console.error('Parse error:', e, 'Pattern index:', i, 'Pattern:', pattern.regex.toString(), 'Match:', match, 'Normalized text:', normalizedText);
            }
          }
        }
        
        // Fallback: Intelligent component-based parsing
        // Extract all date/time components and combine them intelligently
        const components = {
          dayName: null,
          month: null,
          day: null,
          year: null,
          time: null
        };
        
        // Extract day name (sunday, monday, etc.)
        const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        for (const day of dayNames) {
          if (textLower.includes(day)) {
            components.dayName = day;
            break;
          }
        }
        
        // Extract month (november, nov, etc.)
        for (let i = 0; i < months.length; i++) {
          if (textLower.includes(months[i]) || textLower.includes(monthAbbr[i])) {
            components.month = i;
            break;
          }
        }
        
        // Extract time with am/pm
        const timeWithAmpm = text.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i);
        if (timeWithAmpm) {
          const hour = parseInt(timeWithAmpm[1]);
          const minute = parseInt(timeWithAmpm[2] || '0');
          components.time = { hour, minute, ampm: timeWithAmpm[3] };
        }
        
        // Extract 24-hour time (13:30, 14:00, etc.) if no am/pm time found
        if (!components.time) {
          const time24 = text.match(/(\d{1,2}):(\d{2})\b/);
          if (time24) {
            const hour = parseInt(time24[1]);
            const minute = parseInt(time24[2]);
            if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59) {
              components.time = { hour, minute, ampm: null };
            }
          }
        }
        
        // Extract day number (1-31) - but avoid matching time hours
        const dayMatches = text.match(/\b(\d{1,2})(?:st|nd|rd|th)?\b/g);
        if (dayMatches) {
          for (const match of dayMatches) {
            const dayNum = parseInt(match.replace(/(st|nd|rd|th)/i, ''));
            // Skip if it's likely a time hour (1-12) and we already have a time
            if (dayNum >= 1 && dayNum <= 31 && (!components.time || dayNum > 12)) {
              components.day = dayNum;
              break;
            }
          }
        }
        
        // Extract year (4-digit)
        const yearMatch = text.match(/\b(20\d{2})\b/);
        if (yearMatch) {
          components.year = parseInt(yearMatch[1]);
        }
        
        // Combine components intelligently
        let finalDate = null;
        
        // Priority 1: If we have day name, use it
        if (components.dayName) {
          const targetDay = dayNames.indexOf(components.dayName);
          finalDate = new Date(now);
          const currentDay = finalDate.getDay();
          let daysAhead = targetDay - currentDay;
          if (daysAhead <= 0) daysAhead += 7;
          finalDate.setDate(finalDate.getDate() + daysAhead);
        } 
        // Priority 2: If we have month and day
        else if (components.month !== null && components.day) {
          // Create date at noon to avoid timezone issues causing day shift
          finalDate = new Date(components.year || now.getFullYear(), components.month, components.day, 12, 0, 0, 0);
          if (finalDate < now) {
            finalDate = new Date((components.year || now.getFullYear()) + 1, components.month, components.day, 12, 0, 0, 0);
          }
        }
        // Priority 3: Default to today
        else {
          finalDate = new Date(now);
        }
        
        // Apply time if found
        if (components.time) {
          return [this.parseTime(finalDate, components.time.hour, components.time.minute, components.time.ampm)];
        } else if (finalDate) {
          // Default to noon if no time specified
          finalDate.setHours(12, 0, 0, 0);
          return [{ start: { date: () => finalDate } }];
        }
        
        return [];
      },
      
      parseTime: function(date, hour, minute, ampm) {
        try {
          hour = parseInt(hour);
          minute = parseInt(minute || '0');
          
          if (isNaN(hour) || hour < 0 || hour > 23) {
            hour = 12;
          }
          if (isNaN(minute) || minute < 0 || minute > 59) {
            minute = 0;
          }
          
          if (ampm) {
            if (ampm.toLowerCase() === 'pm' && hour !== 12) hour += 12;
            if (ampm.toLowerCase() === 'am' && hour === 12) hour = 0;
          } else {
            if (hour === 12) {
              hour = 12;
            } else if (hour >= 1 && hour <= 11) {
              hour += 12;
            }
          }
          
          if (hour < 0) hour = 0;
          if (hour > 23) hour = 23;
          
          const newDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), hour, minute, 0, 0);
          return { start: { date: () => newDate } };
        } catch (e) {
          console.error('Error in parseTime:', e);
          const newDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0, 0);
          return { start: { date: () => newDate } };
        }
      }
    };
    
    // Make it available globally
    window.chrono = {
      parse: function(text, refDate, options) {
        return SimpleDateParser.parse(text, refDate);
      }
    };
    
    // Enable button immediately since we don't need external library
    window.addEventListener('load', function() {
      const btn = document.getElementById('generateBtn');
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = 'EXECUTE';
      }
    });
  </script>
</head>

<body>

  <script>
    // Clock
    setInterval(() => {
      const now = new Date();
      document.getElementById('clock').innerText = now.toLocaleTimeString('en-US', {hour12: false});
    }, 1000);

    function fillCmd(txt) {
      const el = document.getElementById('eventText');
      el.value = txt;
      el.focus();
    }
  </script>
  <div class="terminal-frame">
    
    <!-- HEADER -->
    <div class="header-bar">
      <div style="display:flex; align-items:center;">
        <div class="status-led"></div>
        <span>QuickCal_TERM_v3.0</span>
        </div>
      <span id="clock">--:--</span>
      </div>

    <!-- WORKSPACE -->
    <div class="workspace">
      
      <!-- INPUT -->
      <div class="input-area">
        <div class="prompt-line">
          <span class="prompt-symbol">root@cal:~#</span>
          <span style="color:#888;">enter_event_details --natural</span>
        </div>
        <textarea id="eventText" placeholder="Meeting next Friday at 2pm..." autofocus></textarea>
        
        <div class="output-log" id="result"></div>
      </div>

      <!-- SIDEBAR -->
      <div class="context-panel">
        <div class="panel-section">
          <span class="panel-label">QUICK COMMANDS</span>
          <ul class="cmd-list">
            <li class="cmd-item" onclick="fillCmd('Sync w/ Team tmrw 10am')">Sync w/ Team tmrw 10am</li>
            <li class="cmd-item" onclick="fillCmd('Lunch next Fri 1pm')">Lunch next Fri 1pm</li>
            <li class="cmd-item" onclick="fillCmd('Flight to SFO Dec 20')">Flight to SFO Dec 20</li>
            <li class="cmd-item" onclick="fillCmd('Doctor appointment next Monday at 10am')">Doctor appointment next Monday at 10am</li>
            <li class="cmd-item" onclick="fillCmd('Birthday party nov 10 2025 6pm')">Birthday party nov 10 2025 6pm</li>
            <li class="cmd-item" onclick="fillCmd('Meeting 11/10/2025 at 2pm')">Meeting 11/10/2025 at 2pm</li>
            <li class="cmd-item" onclick="fillCmd('Gym session tomorrow 7am')">Gym session tomorrow 7am</li>
          </ul>
        </div>
        
        <div class="panel-section" style="flex-grow:1;">
          <span class="panel-label">SYSTEM LOG</span>
          <div style="font-size:0.75rem; color:#444; line-height:1.6;">
            [INIT] Parser loaded...<br>
            [READY] Waiting for input...
        </div>
      </div>
      </div>
    </div>

    <!-- FOOTER -->
    <div class="footer-bar">
      <div style="display:flex; gap:1rem; align-items:center;">
        <span class="key-hint">CTRL + ENTER</span>
        <span style="color:#444;">TO EXECUTE</span>
      </div>
      <button id="generateBtn" onclick="generateCalendar()">EXECUTE</button>
    </div>
  </div>

  <script>
    // No need for loading checks - parser is built-in

    // Split text into multiple events (separated by newlines or common separators)
    function splitIntoEvents(text) {
      // Split by newlines first
      const lines = text.split(/\n+/).map(l => l.trim()).filter(l => l.length > 0);
      if (lines.length > 1) {
        return lines;
      }
      
      // Try splitting by common patterns: double newline, semicolon, or "and" followed by capital letter
      const parts = text.split(/\n\s*\n|;\s*|(?=\s+[A-Z][a-z]+\s+\w+\s+\d)/).map(p => p.trim()).filter(p => p.length > 0);
      if (parts.length > 1) {
        return parts;
      }
      
      // Single event
      return [text];
    }

    // Allow Enter key to submit (Ctrl/Cmd + Enter)
    document.getElementById('eventText').addEventListener('keydown', function(e) {
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        generateCalendar();
      }
    });

    function generateCalendar() {
      const text = document.getElementById("eventText").value.trim();
      const resultDiv = document.getElementById("result");
      const generateBtn = document.getElementById("generateBtn");

      resultDiv.innerHTML = "";
      resultDiv.classList.remove("active");
      generateBtn.disabled = true;
      generateBtn.innerText = "PARSING...";

      // Check if text is empty
      if (!text) {
        resultDiv.innerHTML = '<div class="log-line"><span class="log-ts">[ERR]</span><span class="log-error">NO_INPUT_DETECTED</span></div>';
        resultDiv.classList.add("active");
        setTimeout(function() {
          generateBtn.disabled = false;
          generateBtn.innerText = "EXECUTE";
        }, 100);
        return;
      }

      try {
        const now = new Date();
        const eventTexts = splitIntoEvents(text);
        const allEvents = [];
        
        // Parse each event separately
        for (let i = 0; i < eventTexts.length; i++) {
          const eventText = eventTexts[i].trim();
          if (!eventText) continue;
          
          const results = chrono.parse(eventText, now, { forwardDate: true });

          if (!results || results.length === 0 || !results[0].start) {
            continue;
          }

          const parsedResult = results[0];
          
          if (!parsedResult.start || typeof parsedResult.start.date !== 'function') {
            continue;
          }
          
          const evStart = parsedResult.start.date();

          // Get end time
          let evEnd = null;
          let hasEnd = false;
          
          if (parsedResult.end && parsedResult.end.date()) {
            evEnd = parsedResult.end.date();
            hasEnd = true;
          } else {
            // Default: 1 hour duration
            evEnd = new Date(evStart.getTime() + 60 * 60 * 1000);
          }

          // Extract location if "at <location>" is present (but not "at [time]")
          let location = "";
          const locPattern = /\bat\s+([A-Za-z0-9 ,.'-]+?)(?:\s+(?:on|next|tomorrow|today|monday|tuesday|wednesday|thursday|friday|saturday|sunday|\d{1,2}[:\d]{0,5}\s*(?:am|pm)|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|\d{4}|from|to))/i;
          const locMatch = eventText.match(locPattern);
          
          if (locMatch && locMatch[1]) {
            const potentialLoc = locMatch[1].trim();
            if (!/^\d{1,2}(?::\d{2})?\s*(am|pm)$/i.test(potentialLoc)) {
              location = potentialLoc;
              if (location.toLowerCase().match(/^(at|on|next|tomorrow|today|monday|tuesday|wednesday|thursday|friday|saturday|sunday)$/i)) {
                location = "";
              }
            }
          }

          // Extract summary (event title)
          let summary = eventText;
          
          let dateTimeStart = eventText.length;
          if (parsedResult.text) {
            const dateTimeIndex = eventText.toLowerCase().indexOf(parsedResult.text.toLowerCase());
            if (dateTimeIndex >= 0) {
              dateTimeStart = dateTimeIndex;
            }
          }
          
          summary = eventText.substring(0, dateTimeStart).trim();
          summary = summary.replace(/^(on|at|from|to|next|this|tomorrow|today|monday|tuesday|wednesday|thursday|friday|saturday|sunday)\s+/i, '');
          
            if (location) {
              summary = summary.replace(new RegExp(`\\s*at\\s+${location.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, 'i'), '');
              summary = summary.replace(new RegExp(`\\s*in\\s+${location.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, 'i'), '');
            }
            
          summary = summary.replace(/\s+(on|at|from|to|next|this|tomorrow|today)$/i, '');
            summary = summary.trim();

          if (!summary || summary.length < 2) {
            summary = eventText
              .replace(/\b(next|this|tomorrow|today)\s+\w+/gi, '')
              .replace(/\b(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b/gi, '')
              .replace(/\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d+/gi, '')
              .replace(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/g, '')
              .replace(/\d{1,2}(st|nd|rd|th)?\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*/gi, '')
              .replace(/\d{1,2}(?::\d{2})?\s*(am|pm)/gi, '')
              .replace(/\d{1,2}:\d{2}/g, '')
              .replace(/\s+/g, ' ')
              .trim();
          }

          if (!summary || summary.length < 2) {
            summary = "Event";
          }

          summary = summary.replace(/\s+/g, ' ').trim();

          allEvents.push({
            summary: summary,
            start: evStart,
            end: evEnd,
            hasEnd: hasEnd,
            location: location,
            originalText: eventText
          });
        }
        
        if (allEvents.length === 0) {
          resultDiv.innerHTML = '<div class="log-line"><span class="log-ts">[ERR]</span><span class="log-error">PARSE_FAILED_NO_DATE</span></div>';
          resultDiv.classList.add("active");
          setTimeout(function() {
            generateBtn.disabled = false;
            generateBtn.innerText = "EXECUTE";
          }, 100);
          return;
        }

        // Generate ICS files for all events
        let html = '';
        
        for (let i = 0; i < allEvents.length; i++) {
          const event = allEvents[i];
          
          // ICS formatting - use floating time (no timezone) to avoid day shift
          function fmtICS(dt) {
            const yyyy = dt.getFullYear();
            const mm = String(dt.getMonth() + 1).padStart(2, "0");
            const dd = String(dt.getDate()).padStart(2, "0");
            const h = String(dt.getHours()).padStart(2, "0");
            const m = String(dt.getMinutes()).padStart(2, "0");
            const s = String(dt.getSeconds()).padStart(2, "0");
            return `${yyyy}${mm}${dd}T${h}${m}${s}`;
          }

          const ics = 
            "BEGIN:VCALENDAR\nVERSION:2.0\nCALSCALE:GREGORIAN\n" +
            "BEGIN:VEVENT\n" +
            "SUMMARY:" + event.summary.replace(/\n/g," ") + "\n" +
            "DTSTART:" + fmtICS(event.start) + "\n" +
            "DTEND:" + fmtICS(event.end) + "\n" +
            (event.location ? "LOCATION:" + event.location.replace(/\n/g," ") + "\n" : "") +
            "DESCRIPTION:" + event.originalText.replace(/\n/g, " ") + "\n" +
            "END:VEVENT\nEND:VCALENDAR";

          // Generate Google Calendar URL
          const formatGoogleDate = (dt) => {
            return dt.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
          };
          const googleCalendarUrl = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(event.summary)}&dates=${formatGoogleDate(event.start)}/${formatGoogleDate(event.end)}${event.location ? '&location=' + encodeURIComponent(event.location) : ''}&details=${encodeURIComponent(event.originalText)}`;

          html += `
            <div class="log-line">
              <span class="log-ts">[SUCCESS]</span>
              <span class="log-msg">EVENT_CREATED: ${event.summary}</span>
            </div>
            <div class="log-line">
              <span class="log-ts">[DATA]</span>
              <span class="log-msg">${event.start.toLocaleString()}${event.hasEnd ? ' - ' + event.end.toLocaleString() : ''}</span>
            </div>
            ${event.location ? `<div class="log-line"><span class="log-ts">[LOC]</span><span class="log-msg">${event.location}</span></div>` : ''}
            <div class="result-actions">
              <a href="data:text/calendar;charset=utf8,${encodeURIComponent(ics)}" download="event${allEvents.length > 1 ? '-' + (i + 1) : ''}.ics" class="res-link">DOWNLOAD_ICS</a>
              <a href="${googleCalendarUrl}" target="_blank" class="res-link">GOOGLE_CAL</a>
            </div>
            <div style="height:20px;"></div>
          `;
        }

        resultDiv.innerHTML = html;
        resultDiv.classList.add("active");
        setTimeout(function() {
          generateBtn.disabled = false;
          generateBtn.innerText = "EXECUTE";
        }, 100);

      } catch (error) {
        console.error('Error generating calendar:', error);
        resultDiv.innerHTML = '<div class="log-line"><span class="log-ts">[CRITICAL]</span><span class="log-error">SYSTEM_FAILURE</span></div>';
        resultDiv.classList.add("active");
        
        setTimeout(function() {
          generateBtn.disabled = false;
          generateBtn.innerText = "EXECUTE";
        }, 100);
      }
    }

    // Auto-focus textarea on load
    window.addEventListener('load', function() {
      document.getElementById('eventText').focus();
    });
  </script>

  <!-- Product Links Section - Full Width at Bottom -->
  <div class="product-links-section" style="width: 100%; max-width: 100%; margin-top: 60px; padding: 40px 20px; background: var(--bg); order: 2;">
    <div style="max-width: 1200px; margin: 0 auto; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 3rem 2rem; text-align: center;">
      <h3 style="font-size: 1.5rem; font-weight: 700; color: var(--text-main); margin-bottom: 1rem; font-family: var(--font-mono);">Shop NutriThrive Products</h3>
      <p style="color: var(--text-dim); margin-bottom: 2rem; font-size: 1rem;">Discover premium superfoods and wellness products:</p>
      <div style="display: flex; flex-wrap: wrap; gap: 12px; justify-content: center; margin-bottom: 2rem;">
        <a href="https://nutrithrive.com.au/pages/products/product-detail.html" style="background: var(--accent); color: var(--bg); border: none; padding: 12px 24px; border-radius: 4px; text-decoration: none; font-weight: 600; font-family: var(--font-mono); font-size: 0.9rem; transition: all 0.1s;">Moringa Powder </a>
        <a href="https://nutrithrive.com.au/pages/products/product-curry-leaves.html" style="background: var(--accent); color: var(--bg); border: none; padding: 12px 24px; border-radius: 4px; text-decoration: none; font-weight: 600; font-family: var(--font-mono); font-size: 0.9rem; transition: all 0.1s;">Curry Leaves </a>
        <a href="https://nutrithrive.com.au/pages/products/product-black-tea.html" style="background: var(--accent); color: var(--bg); border: none; padding: 12px 24px; border-radius: 4px; text-decoration: none; font-weight: 600; font-family: var(--font-mono); font-size: 0.9rem; transition: all 0.1s;">Black Tea </a>
        <a href="https://nutrithrive.com.au/pages/products/products.html" style="background: transparent; color: var(--accent); border: 1px solid var(--accent); padding: 12px 24px; border-radius: 4px; text-decoration: none; font-weight: 600; font-family: var(--font-mono); font-size: 0.9rem; transition: all 0.1s;">All Products </a>
      </div>
      <div style="margin-top: 2rem; padding-top: 2rem; border-top: 1px solid var(--border);">
        <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">More Free Tools:</p>
        <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
          <a href="https://nutrithrive.com.au/crazy-ideas/index.html" style="color: var(--text-dim); border: 1px solid var(--border); padding: 8px 16px; border-radius: 4px; text-decoration: none; font-family: var(--font-mono); font-size: 0.85rem; transition: all 0.1s;">NutriThrive Tools </a>
          <a href="https://scintilla.world/" style="color: var(--text-dim); border: 1px solid var(--border); padding: 8px 16px; border-radius: 4px; text-decoration: none; font-family: var(--font-mono); font-size: 0.85rem; transition: all 0.1s;">Scintilla World </a>
        </div>
      </div>
    </div>
  </div>
</body>

</html>
